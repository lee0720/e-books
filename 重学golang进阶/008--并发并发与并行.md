---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 并发和并行

了解并发 (concurrency) 和并行 (parallesim) 的区别。

  * 并发：逻辑上具备同时处理多个任务的能力。
  * 并行：物理上在同一时刻执行多个并发任务。
  * 并发是并行的基础，并行是并发的理想执行模式。
  * 单核（多线程）或单线程（协程）可通过任务切换实现并发。
  * 多线程和多进程是并行的必备条件。

并发编程模型现在属于必备的知识。现代语言都在简化并发编程模型，并发编程本身也引发出各种各样的模式，操作系统对于并发本身的支持粒度也越来越大。就算单进程程序，我们也会在多台机器上部署分布式应用，分布式应用本身也是并发模型。并发并不是意味着在单机上实现，物理上的多机器和多核并发模型称之为并行。

并发和并行有什么不同？并发是逻辑上的，并行是物理上的。

在了解并发之前有些概念需要梳理一下。

**进程**

进程是一个抽象的概念，进程是代表整个内存地址空间以及相关的文件、图片、声音这些资源。它是一个资源的边界。

**线程**

所有的指令必须要交给某个线程来执行，线程是用来执行的。我们把线程或者操作系统的轻量级进程统称为系统线程。

**时间片**

在单核的情况下只有一个逻辑执行，CPU 把时间分成一片一片的，称之为时间片。假设每个时间片是 60 毫秒，那么 CPU 先执行 60 毫秒逻辑，再切换执行
60 毫秒另外逻辑，再切换原来逻辑再执行，就这样一直切换。CPU 可能使用不同线程执行同一段逻辑。

如果只有一个线程两个逻辑 A 和 B 是串行执行，先执行 A 再执行 B。逻辑 A 可能有 IO 操作，比如等待文件、等待网络数据。IO 操作通过 DMA
方式不需要 CPU 执行，也就是 CPU 在 IO 执行时间内再等待，这种情况下浪费 CPU
的一段时间片。操作系统调度时间片分配，如果操作系统发觉调度时间片每次利用很少，造成程序的优先级会越来越低，会逐步缩短时间片，这样导致这个程序提高优先级时出现卡顿的行为。

**并发**

多线程就是并发么？严格来说，并发和线程没有直接的关系。

什么叫并发？从逻辑上指的是多个逻辑同时执行。逻辑是由一堆代码组成，什么叫同时执行？同时是相对的，相对具体的度量单位，比如在一个小时内同时完成。所以逻辑上同时执行，未必是物理上同时执行。

**并行**

什么叫并行？并发是基础条件，并行是并发执行模式。

程序实现接近于所谓物理上的同时，并行的前提有两个，第一程序编程模型支持并发，第二部署的物理环境支持用并行方式执行并发。

### 同步和异步的区别

日常开发最常见的两个概念是同步和异步，同步和异步有什么不同？同步与异步和阻塞非阻塞什么关系？

比如客户端和服务端。服务端不一定是服务器，可能是从硬盘上读文件或者从网络上读数据。通信就是一端往另一端进行通信。

**同步**

所谓同步就是客户端发送请求服务器返回结果，在没有返回结果之前客户端一直处于等待状态，这个等待操作是由客户端主动发起的。同步方式是客户端决定等待。

向服务端发送请求，返回结果是什么？服务端存在两种状态：

第一种方式是非阻塞方式：服务端有数据，直接返回数据。服务端没有准备好数据，返回数据长度为零同时返回状态码，这个状态码可能是错误值，或者连接关闭错误值，错误值也是状态，直接返回状态。

第二种方式是阻塞方式：服务端没有数据，客户端读取数据过程中服务端可能还没有发送数据，服务端一直等待直到缓冲区填满返回数据。

无论阻塞方式还是非阻塞方式客户端都是等待状态，只有服务端返回结果客户端才中止等待。所以通常意义下，同步与阻塞非阻塞没有任何关系，服务端返回两种结果的一种，在返回结果之前都需要等待，阻塞非阻塞是服务端的行为。

**异步**

异步方式指的是客户端不会等待，客户端只向服务器端发送类似注册某种行为请求。这个请求不是调用而是更倾向于信号，当然从编码上看是调用函数，但是从逻辑上看是信号。比如注册读写
IO 操作。

服务端收到请求后客户端继续执行其他逻辑，客户端在接收信号之前不关心上次处理的请求。所以这种异步请求不是连续性的。服务端处理完尝试给客户端发送请求，这个请求分成几种，第一种回调
callback，第二种是信号 singal，第三种是通过某种机制把数据暂存。

**小结**

所以同步方式的重点是在客户端，异步方式的重点是在服务端。同步和异步最大的差别是当服务端有结果时，客户端处于什么状态。

如果客户端处于等待状态，称之为同步方式。

如果客户端没有等待状态，称之为异步方式。

### 同步和异步实现方式

其实并发并不是确切的技术，而是一种编程范式。既可以把同步变成异步，也可以把异步变成同步。比如把同步变成异步，类似协程把等待的任务放到线程池中执行。所以研究理论时不需要关心并行真正的意义。

同步和异步实现更多的是一种编程范式。

同步方式最常见的有：

  * blocking：阻塞操作。读写 IO 操作
  * non-blocking：非阻塞操作。读写 IO 操作，会立即返回两种状态
  * multiplexed/epoll：大部分编程模型都是基于这个实现，在没有包装之前实际上是同步方式，这种方式称之为 IO 复用。

为什么 epoll 是一种同步模型，epoll 正常操作是这样的。

首先注册一批 FD，FD 就是文件描述符，文件描述符可能是文件或者网络，在类 Unix 系统（Unix-like）下所有都可以看作文件。

注册完循环检查哪些 FD 可以操作，客户端循环等待，等待分为阻塞和非阻塞。

每次检查返回三种结果：第一种数据已经准备好的是非阻塞模式，第二种数据没有准备好的是阻塞模式，第三种没有数据也是一种结果。这时客户端处于等待状态是同步方式。

所以正常情况下 epoll 是一种同步模型。实际上我们很少直接使用 epoll。

异步 asynchronous/signal 方式最常见的有：

  * AIO：Linux 下以 AIO 开头的异步 IO API，需要单独调用使用，正常情况下系统调用都是同步模型。
  * IOCP：IOCP 异步调用是 windows 下最常见的开发模式。
  * glibc/kernel：异步操作有基于内核实现的，也有基于库实现的。

正常的并发模式怎么设计呢？

我们首先需要一个调度器，调度器有一列表用来存放需要的异步调用。用线程循环检查调度器的列表。检查异步调用怎么注册的，用什么方式通知的，什么异步结果。通知方式有缺省操作、信号、回调函数。

第一种方式是缺省操作，比如执行向硬盘写 10G 的文件写操作，需要很长时间对结果不关心则返回缺省操作。

第二种方式是服务端处理完发送一个信号，客户端可以选择监听这也可能选择不监听。监听这个信号实现的是操作系统级别的软中断，软中断会临时中断当前的执行，把这个流程临时转到处理结果，处理完继续执行。

第三种方式是执行回调，处理结果不干扰主要的执行流程。大部分并发模型都是基于回调设计。它的优点是分离主流程和异步流程，用一个线程单独执行回调，回调函数和请求不在同一个线程执行。最典型的是
NodeJS。

选择不同的模型，处理的方式有很大差别，相应执行性能有很大差异。

### 并发模型

**不同并发模型选择**

  * 多进程实现分布和负载平衡，减轻单进程（垃圾回收等）压力。
  * 多线程抢夺更多 CPU 资源。
  * 协程提高 CPU 时间片利用率。

实现并发可以在多种模型中去选择，现在有三种模型，多线程模型和多进程模型和协程模型。

**多进程模型**

多进程模型是把线程 1 封装到进程 1、线程 2 封装到进程
2，用多个进程执行。单个进程请求量非常大会导致内存开销也会非常的大，多进程模型对于单个进程来说压力小很多，其中某个进程崩溃可以保证其他的可以继续服务，天生的分布式结构。

对于 CPU 密集型比较高的 (数据解密、图像处理) 程序使用多进程模型，这样的优点是：

  * 第一对于操作系统来说这个进程的优先级好控制，分配的时间片和接收任务的时间片分离。

  * 第二弹性更高，很容易部署迁移到其他机器上。两个进程相互通信最简单的方式是 RPC 或者 Socket 或者 MQ、数据库。

  * 第三数量更有弹性。在一个进程里创建很多线程对于操作系统来说都是被监管的，并没有多个进程处理起来更流畅。

多进程的缺点在于数据复制，进程内不用复制数据而直接使用共享内存地址。

**多线程模型**

正常情况下优先使用多线程。多线程的目的是尽可能多的获取时间片。多线程的缺点是由于存在 IO 操作，所以单个线程的 CPU 利用率不是很高。

操作系统有操作时间片的调度器，操作系统按照线程分配时间片。

**调度线程**

  1. 时间片执行完需要把线程 1 的寄存器等状态保存起来，然后调度线程 
  2. 载入线程 2 的状态，然后再把状态保存，然后再调度给线程 
  3. 调度时除了本身函数执行的消耗以外，还有上下文切换，会导致很大的额外开销，整体性能反而会很低。

**协程模型**

协程模型是程序通过切换的方式实现在单个线程内、在单个 CPU 上执行来提高 CPU 的利用率。协程的目的是充分利用 IO 等待浪费的时间片。

比如逻辑 A 和 B 可能是两个函数。逻辑 A 执行 IO 操作时，它会立即把控制权交给逻辑 B 执行；逻辑 B 执行 IO 操作时，再交还控制权执行逻辑
A。这样的目的是充分利用 IO 等待的时间（CPU 暂停的时间）。

在同一线程上逻辑 A 和逻辑 B 相互把控制权移交给对方，时间片可以全部利用。这种情况下逻辑 A 必须知道逻辑 B，逻辑 B 必须知道逻辑
A，它们之间构成强引用关系。正常情况下逻辑 A 和 B 之间不可能知道对方。

这时需要调度器的角色，它用来隔离逻辑和保证公平性。

所有的任务放到调度器的队列中，调度器先调度逻辑 A，如果逻辑 A 执行 IO 操作，调度器把 IO 操作进行事件注册。当 IO
操作返回接收一个信号，调度器把事件注册也放到调度器的事件队列中。

然后按顺序调度逻辑 B，当 B 引发 IO 操作同样的也产生事件机制，把控制权返还给调度器。

按顺序调度 C 时，调度器可能从事件注册队列中查询注册的事件是否有返回，如果有返回重新调度 A。

有了调度器的角色，由调度器保证公平性，公平性策略有很多种，比如优先处理队列的任务，或者每处理两次队列任务就检查事件返回，调度器也可以把本身放到到事件队列中调度。很多协程框架都有事件池这样的概念。

调度器的关键是怎么调度，怎么保证公平性，怎么尽快的执行。

协程面临主动移交控制权的问题，一些编程语言实现协程通过类似 yield 指令移交控制权。

协程不是系统级别的概念，而是编程语言提供的编译器跳转指令。通过操作系统强行移交时间片控制权是抢占式的，而协程的协指的是协作的意思。

我们做架构设计选择并发模型的时候，不同语言有不同方式，Python 一般使用多进程加上协程模型组合，Go
语言严格来说不是协程，一般使用多线程加上协程模型组合变种，它的模型相对来说比较复杂。

现代大多数语言都在操作系统上封装了一层虚拟机，操作系统、各种沙箱也可以看作虚拟机，因为操作系统也隔离一层硬件。所以并发多少任务和拥有多少 CPU
并没有关系，并发也有可能交叉执行。

### 并发模型选择

最常见的并发模型，以 WebServer 为例，启动 P 监听 Listen 一个端口，可以启动多个子进程处理用户接入，处理相应的数据。P
可能是子进程，也可能是线程。

用多进程模型的优点是对于 cpu 处理能力相对来说比较强，缺点是父进程子进程相互之间存在管理关系，因为很容易出现僵尸进程。

这种模型最关键的问题是 P：

第一所有的请求是由 P 引发的，操作系统只能看到 P 的监听，操作系统把请求给 P，当有海量接入的请求时，P 会成为很大的瓶颈。

第二 P 本身负载均衡能力很差，它不能平均的分摊至各个子进程。这和 P 本身设计有关系，因为很多语言有运行时处理，不是由操作系统提供的。

第三 P 假死后整个并发框架全部死掉。

### 重用端口模型

重用端口模型就是启动多个进程，多个进程监听同一个端口，由操作系统把请求平均分配给不同的进程。

这样模型的优点是：

  * 第一：负载均衡均匀，操作系统实现相比程序负载均衡能力更强。

  * 第二：其中任何一个死掉不影响其他进程。

  * 第三：可以实现无缝升级。

在常见 Socket 编程中，`SO_REUSEPORT`
选项重复使用端口。可以用多个进程监听同一端口，操作系统把用哈希表保存监听的多个进程，把请求均匀分摊到多个进程。我们用重复使用端口实现多进程模型，因为传统的多线程多进程架构有很多缺陷。

很多程序员太依赖各种框架反而忽略了操作系统提供的功能，框架的并发模型未必是最合理的，很多框架为了实现跨平台使用是最常见的功能，某些时候我们需要针对特定版本的内核提供的特性对框架适当的改造或者裁剪。

### 小结

并发的方式有很多种，可能多台服务器、多进程的、多线程的甚至还涉及到协程。它们的粒度不同，选择什么样的模型和我们的架构有关系，比如我们做负载均衡或者灾备的时候可能选择多台服务器，如果我们希望可以把某些调度固定到某些核上面避免频繁这种上下文切换，可能会采用多进程模型。而多线程尤其系统线程可以让我们更多的获得时间片，协程则是在单个时间片上尽可能减少时间片的浪费。

实际上我们很少会使用单种模型，我们会把几种模型叠加起来使用，从大的架构层面一直到算法层面去逐步优化，用多种模型方式去把我们的执行性能调度到最佳状态。

并发模型除了理解并发并行以外，同步和异步对并发模型有非常大的影响，我们需要知道同步和异步是由谁来调度，在客户端调度还是在服务端调度。

另外阻塞和非阻塞和同步异步没多大关系，和具体实现有关系。可以用同步方式实现并发模型也可以用异步方式实现并发模型。

并发模型有个关键词非常重要，就是性能。性能更明确称之为吞吐量，吞吐量包括接入数量 qps，单位时间内 IO 的吞吐量。

