---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
编程就是把具体实现抽象，屏蔽底层的一些细节。数据就像一条流水线，从一个并发单元传递到另一个并发单元。那么我们怎么传递数据呢？基于内存共享或者基于网络传输？

### 数据共享方式

![](https://images.gitbook.cn/OO5M7O)

同一进程内有不同的并发单元，例如 goroutine A 和 goroutine B，它们可能在不同的物理核上并发执行，如果访问同一个变量数据，A
读写数据时 B 不能写入，同理 B 读写数据时 A 就不能写入，否则会产生数据竞争效应。在早期两个线程之间数据交互最常见的方式是共享变量。

共享变量就是一个数据被多个并发单元共享，最常见的使用互斥锁来避免数据竞争效应。即多个并发单元共享一个状态，只有一个并发单元拿到锁，在锁释放之前其它的并发单元都处于阻塞状态。

![](https://images.gitbook.cn/onYhrw)

另外的方式是在多进程之间交换数据的方法是共享同一块内存，父进程有多个子进程，父进程使用 `mmap` 创建一块内存块，把这个内存块声明为多个子进程共享。

上面两种方法都是基于内存共享的方式。除了内存共享方式以外还有基于文件交换、基于 IPC 管道机制、在同一个网卡上基于 socket
通讯传递数据包。在单台机器内通过文件交换，文件加锁确保只有一个进程能打开文件。另外还有通过网络传输方式。

#### 基于消息队列

![](https://images.gitbook.cn/aLsfHV)

在架构设计中最常见的模型是基于消息队列实现异步架构模型，在多个并发单元之间构建消息队列。消息队列称之为基础组件，消息队列连接不同的生产者消费者。消息队列的种类有
Kafka，redis 等，实现方式通常是跨进程或者跨机器，可以实现离线操作和解耦。使用消息队列有一些优点：

第一个优点是生产者和消费者之间不需要知道对方的存在，没有关联，任何一个节点都可以临时关掉、临时扩容和升级。生产者和消费者只关心自己。生产者只负责生产数据然后把数据放到消息队列中，至于谁消费什么时候消费与生产者无关，而消费者从消息队列中取数据。

第二个优点是生产者和消费者的数量可以动态调整。生产者把数据放到消息队列中，消息队列有缓存机制或者持久化机制，消费者可能定时启动。生产者可能是在线的服务产生大量的日志，消费者可能是离线的服务。在线服务通常要接近于准实时的处理状态，消费者可能是周期性的利用晚上时间把生产者生成所有的数据做一次统计处理。

在系统架构中利用消息队列机制处理不同的并发量，更好的处理负载平衡。我们通常说的负载平衡是利用反向代理连接多台服务器。相对静态负载均衡，动态负载平衡可能是基于容器的概念，把所有服务器全部做成容器托管环境，它可以根据请求量动态调整容器的数量，启动服务时开启动态容器，当服务结束时关闭所有容器。

现在架构强调的是异步处理的方式，传统线性或者串行流处理已经不再流行，串行流的问题是任何一个节点出现问题整个处理链都会断掉。生产者和消费者之间一般不做即时处理，也不做串联处理，做串联的话生产者所有的请求都会同步请求到消费者上对后端的压力非常大。一般生产者产生数据临时放到消息队列中，消费者允许在处理上有时间差，因为生产者需要接入海量处理，消费者不需要。

#### 基于 CSP 模型

**1\. 问题引入**

下面用一段伪代码来说明通过共享内存带来的问题。这是很典型的通过共享内存来实现协作机制，把数据保存在某个地方，另一个并发单元不停的检查。它们通过共享内存的方式实现不同并发单位之间的数据传递。缺点是基于共享内存，产生数据竞争效应，还不能保证是原子操作。

    
    
    func main() {
        // 有个函数，它们可能共享一个容器 x
        var x int
        // 不停的检查 x 是否大于 1，通过循环监控拿到通知
        go func() {
            for {
                if x > 1 {break}
            }
        }()
        // 先做事情，然后把 x 设置为 1，这样产生一个通知
        go func() {
            //do something
            x = 1
        }()}
    

上面的问题是，当并发单元 A 往容器 x 中写数据，并发单元 B 监控容器 x，写数据不能保证是原子操作，并发单元 B
可能接收到一个不完全的状态。如果容器是整数还好，如果是字节数组 A 和 B 读取的数据长度可能都不一致。而且数据竞争时对于缓存、CPU
管理、内存都会存在一系列的问题。所以要注意先共享内存还是先传递信号。多个并发单元共享一份内存，最常见的是 A 向一个地方写一个状态，B
通过监控状态达到通知请求。任何时候 A 和 B 都不应该同时持有一份内存。

现在通信的理念是不要以共享内存的方式进行通信，而是先通信后共享。

  2. 实现方式

第一种方式是传地址方式。以 A 和 B 为例，A 往容器 x 中写数据，拿到地址 P，把 P 传给 B，A 指向 P
的引用就立即失效，这个内存实际上是被管道引用的，B 拿到数据只有 B 持有这个内存引用。A 把它生成的数据放到动态内存中，接下来通过管道向 B
发送消息，消息的内容可能是动态内存的地址，B 接收消息，连接这个地址，A 就放弃对动态内存地址的引用，这样 A 和 B 之间就不会共享同一份内存。

第二种方式是传值方式。对于小数据把数据打包传递给 B，实际上复制数据，它们不会产生共享。

这是很典型不要用共享内存进行通信，而是基于通信共享内存的理论。先通信后传递数据方式优点是只有一方拿到目标数据的引用，通信代表一种令牌，代表一种控制权限的转移，管道实际上承担着控制权转移。通过控制权限的转移确保只有一方持有这个数据，确保数据不会有数据竞争效应。设计并发需要注意，并发单位之间进行内存的协调或者数据的通信有多少并发单位持有数据。

另外可以通过同步加锁的方式，缺点是 A 和 B 并发变成串行，在任何物理时刻只有一个工作，处理效率低。

  3. CSP 模型定义

基于通道的方式或者基于消息队列的方式实现消息的传递，这种方式叫做 CSP 模型。CSP
模型简单来说用通讯来代替内存共享。因为通讯本身可以扩展的，最简单的通讯是发送一个事件或者发送一个信号，然后复制内存，甚至不复制内存。发送方发送消息，这个消息可能是指针，当接收方确定接收到这个消息后，发送方就放弃这个指针，把这个指针交给接收方，这个内存块的唯一引用就从发送方变成接收方了。

拷贝数据有两种方式，一种方式是使用两块内存，发送方把完整数据复制一份交给接收方。第二种方式是使用同一块内存，发送方把指向数据内存的指针交给接收方。交给接收方后只有接收方持有这个指针，发送方不持有这个指针，类似权限的转移方案。

使用指针方式的优点是可以避免内存复制的开销，也避免在堆上创建两个对象。使用数据拷贝方式需要在堆上复制两个对象，对象接收以后，第一个对象需要 GC 回收。

通讯代替内存共享并不意味着不用内存共享，所谓的内存共享指的是生产和消费同时持有某个数据。如果同一块内存的引用转移给另外一方，这也叫一种通讯。转移指针也是一种通讯。

  4. 语言支持

Go 语言从 runtime 底层就支持并发模型，它大量使用 CSP 模型实现很多的并发操作，因为 main 函数是 goroutine，垃圾回收是
goroutine，后台监控是 goroutine，所有的东西都是 goroutine。goroutine 之间发送消息，它并没有 windows
消息通道一说，我们知道 windows 所有的窗体事件都是由消息实现的，但是在 Go 语言终端层面没有这种机制，必须用自己的方式实现消息通道，这种通道用
Channel 实现。CSP 模型虽然从底层实现上有些差别，但是原理上是非常类似，通过了解这种并发的操作转其它语言的时候会少很多的障碍。

在架构层面经常使用 CSP 模型。就像很熟悉的管道
Pipeline，有两种方式来实现，第一种方式通过内存来实现，第二种方式通过文件来实现。本质上和通道非常类似，无非有一种方式来维持它的管道顺序，发送的时候必须保证每个块被消费掉。这种方式完全是借鉴
Channel 通道模型。

  5. CSP 模型不同实现区别

用通讯代替内存共享的方式通常称之为 CSP 模型。典型的两种实现是 Erlang 语言的 Actor 模型、Go 语言的 Channel
模型。这两种模型有什么区别呢？

电子邮件其实也是一种消息通讯方式，邮件发送到对方的信箱，不需要关心怎么发送、对方实时接收、中间经过多少服务器。

Actor 模型类似电子邮件。关心的是谁接收这个消息，不关心怎么传输，不关心本机的内存共享传输还是跨机器网络传输还是用其它方式。Actor
模型对底层的通讯方式不关心，只关心谁接收数据，所以它天生是异步的。

Go 语言的 Channel 模型关心的是数据放到哪个管道，不关心谁接收，所以它天生是同步的。通道是有状态的。目前 Channel
模型只能在进程内进行通讯，也有项目基于这种模型开发 TCP 通讯。

所以这两个 CSP 模型有很大差别。Actor 模型关心的是数据交给谁。Channel
模型关心的是数据放在哪个通道。不同的关注点决定选择的不同的模型。Channel 模型适合做实时计算，Actor
模型适合做分布式模型。所以选择模型需要知道各自的特点。

CSP 模型是解决方案，更倾向于架构层面上的解耦，原先两个串行数据变成中间有缓冲机制解除对方的耦合。

Actor 模型只需要把数据放到某个地址，只处理数据包，这个地址实际上是一个缓冲池。

Channel 模型只需要把数据放到某个通道，不需要知道对方，没有耦合关系。

虽然 Go 语言在各种各样的算法中频繁的使用通道，相比较内存共享它的抽象度更高，缺点就是性能上要付出额外的代价。

#### 通道的控制权

共享数据最简单实现是创建全局变量，通过锁的方式处理数据的共享。表面上看起来没有问题，但是从编码的角度考虑不应该是如何保护这份数据，而是应该申请拿到数据的控制权。

正常情况下，不应该直接暴露数据，尽可能避免单独持有全局变量的数据，而是通过函数内部逻辑控制所有的消费者。通过函数内部逻辑保护数据，而不是直接暴露数据。在内部可以记录有多少请求请求这份数据，可以对请求同步对请求排队。

编码实现上是把全局变量转化为函数，抽象层面是申请控制权，申请控制权会对这份控制权做出处理，要不独占控制权，要不共享控制权。共享控制权需要考虑第一多读单写，第二数据拷贝。任何时候不应该直接处理数据，而是跟逻辑打交道，逻辑决定怎么持有数据控制权。

消息队列本质上把数据按照一定的方向去传递，可能是单向的，也可能是双向的。消息队列可能是分布式跨多个机器，把它当成网络通讯的一种抽象体。按照 CSP
的原则尽可能用通道传递数据避免基于内存共享，因为内存共享会导致数据竞争效应。

通道从某种意义上来说就是一个抽象，我们不能用传统的 CSP
模型或者消息队列的方式去理解通道，它实际上是在进程内处理数据，它是数据控制权的转移。当我们从发送方把数据通过通道传给接收方的时候，第一数据依然在一个进程内，第二数据只是控制权从发送方转给接收方。转移可以看做类似函数调用，函数调用考虑的是值拷贝还是指针拷贝，而传统的消息队列则需要把数据序列化，然后反序列化。所以通道关注不是数据而是数据的控制权，数据从发送方发到接收方是转移了控制权。

当我们把数据发送给通道的时候实际上变相的把控制权移交给通道，让通道把控制权转给接收者。当我们把数据交给通道时候，发送者不应该持有这份数据。如果发送者和接收者同时持有这份数据控制权可能导致出现数据竞争非安全因素。发送者把数据移交给接收者后，发送者控制权消失，如果发送者想重新授权，需要把发送者换成接收者的方式。任何时候数据控制权最好控制单一方而不是暴露多方，使用全局变量实际上是把这份数据暴露多方，因为不知道有多少人会去拿这份数据。

调用函数传递参数肯定复制参数，复制参数需要考虑数据在栈上复制还是在堆上复制，会不会出现逃逸，通道同样面临这样问题。

通道是一个抽象概念，它并不真实存在，不用考虑序列化。传统的消息队列是分布式架构，在性能允许的情况下尽可能地将控制权分散。CSP
的理论是不应该多方拥有同份数据的控制权。

任何时候消费者只需要拿到数据，思考的模式是怎么处理控制权，通道也一样。Go 语言默认情况下都是以 goroutine
方式运行，都会面临数据共享问题，存在数据竞争问题。创建数据需要搞明白这份数据的控制权到底在哪里。

#### 小结

通道用途在于传递“消息”。

  * Go 并未在语言层面实现严格并发安全。
  * Go 鼓励 CSP 模式。以通信代替内存共享，实现并发安全。
  * channel 是显式的，需操作双方事先约定数据类型和持有通道引用。
  * channel 不关心另一方身份和人数。如对方未准备妥当，可能引发阻塞。
  * channel 所发送消息，除数据外，还可是“事件”。

从实现层面上计算机内存里都是数据，计算机的作用就是把数据抽象成结构。通道传递的是消息，不能把消息等同于数据。消息和消息队列不同，消息队列用来处理数据，逻辑是分散在两端。消息未必，消息可以传函数，类似
RPC 的概念。

Go 没有实现语言层面上并发安全。有些语言提供了语言层面并发，比如所有变量都是只读的，所有的数据都是拷贝的，需要加关键字设置可写。Go 早期设计理念基于
Next C 提供足够多的自由，继承汇编，控制计算机的所有层面。

通信实际上是把消息复制，如果以内存共享的方式，存在数据竞争。利用通道的编排效应来实现并发安全，这是在编码方式上的一种设计。另外通道是显式的，数据传递有两种方式，比如每个节点都处于星状网络的终端，类似邮箱发送数据只要把数据扔到邮箱里，不需要保持长期的联系，不需要管谁发的以及发的是什么。另外一种方式就是通道，双方必须通过一条直线联系，发送的数据必须明确。

为什么不使用邮箱方式？因为效率不高。基于单进程内的模型来说，首先约定数据类型后面处理非常方便，而且可以规避数据复制。所以通道的设计和我们传统的 MQ
不太一样，MQ 更鼓励通过 CSP
实现分布，通道不是用来处理分布，而是用来处理数据转移，因为通道不是跨进程的。另外通道还可能会引发阻塞，同步需要碰面完成私下交易。异步需要数据槽满没满，可能引发阻塞效应。另外数据转换成消息这种抽象模型，可能是事件，没有发送数据。

    
    
    func main() {c := make(chan int)
        go func() {defer close(c) // 引发关闭事件
            d := <-c       // 接收数据
            println(d)
        }()
        c <- 100 // 发送数据
        <-c      // 等待关闭事件
    }
    

上面例子创建一个同步通道，创建 goroutine 用来接收，同步通道不能在同一个 goroutine 上，所以 main goroutine
作为发送方，新的 goroutine
作为接收方。接下来把关闭通道作为事件通知。在发送方发送数据后等待通知，关闭通道解除阻塞。所以我们用通道同时做两件事，第一用来发送数据和接收数据，第二用来等待事件和引发事件。

没有等待事件和引发事件看起来也没有问题，因为它会阻塞等待数据结束。但问题是等待数据完成后，通道可能立即退出，可能会导致 `println(d)`
不会执行。所以必须明确要等待通道逻辑结束，等待关闭事件和引发关闭事件。我们除了考虑通道，还可以考虑能否用通道来编排不同 goroutine 执行次序。

### 通道模式

依内部数据处理方式，可分同步或异步（或缓存）两种。

  * 同步：收发双方直接交互，会阻塞，需要在不同 goroutine 操作。
  * 异步：内置一定数量缓存槽。依槽内状态决定是否需要阻塞。

按照官方的说法，通道分同步的和异步两种方式，它在内部实现上是一回事，本质上区别在于它内部有没有数据槽。它的内部有个数据槽，数据槽用来存储数据，还可以称之为数据缓冲区。另外发送方和接收方还有两个队列。同步方式的情况下，数据槽是零，也就是数据槽不能存数据。发送数据类似送快递，送快递有两种方式，一种方式是打电话叫谁来收一下快递，也就是同步方式，一种方式是快递柜寄存，也就是异步方式。同步方式必须收发双方直接交互，异步方式考虑数据槽的问题。

`c := make(chan int)`：同步方式，数据槽大小为 0。 `c := make(chan int, 3)`：异步方式，3 个数据槽。

#### 同步方式

![](https://images.gitbook.cn/1lvyh2)

同步方式是什么意思呢，例如快递员是发送方，不存在快递柜，提前说好在某个地方等，这个地方就是通道。同步方式下通道的作用是把发送方接收方联系在一起，不关心对方是谁，约定传递是什么类型数据。这时候出现几种情况：

  * 发送方先到接收方没到，则发送方在通道一直等待接收方，接收方到达把数据交给接收方。
  * 同样的，发送方没到接收方先到，则接收方在通道一直等待发送方。

究竟怎么等待呢？实际上通道有两个队列：发送方的等待队列和接收方的等待队列。

比如发送方先到接收方没到，发送方把自己放到发送者队列中休眠状态变成等待状态。因为 goroutine 方式是当任务 G 阻塞必须交还 M 和
P，避免任务堵死或者饿死。接收方到达后，首先检查通道有没有数据，如果没有数据，接收方向发送等待队列发送信号执行唤醒操作，从休眠状态激活。发送方被唤醒，进行交换数据。完成交换数据后不再需要通道，通道只是通知。同样的，接收方先到，接收方也会进入接收的等待队列进行休眠，由发送方进行唤醒。所以在同步方式下，不管是谁先到，都需要等待进入阻塞状态，收发双方必须同时到才完成数据交换。

接收方和发送方就是数据的生产方和消费方，接收方和发送方唤醒并不需要对方的身份。发送方唤醒任意一个接收方把数据给接收方。所以同步方式关心的是发送方和接收方，发送方和接收方需要同时到场，发送方和接收方配对后把数据直接交给对方，通道并不需要额外缓存这个数据。

所以同步通道是抽象的概念，同步方式是缓冲区为零的通道，不会缓存任何数据。通道只是确定生产方和消费方的角色，而不需要知道对方的身份，只需要把数据给对方，所以同步方式需要配对，但是是低耦合的。实际上通道关联两个队列，一个是等待队列，一个是发送队列。

编码上使用同步通道需要注意收发双方不可能处于同一个 goroutine，处在同一个 goroutine
意味着排队的情况下没有对方唤醒，没有接收方发送方会阻塞。

#### 异步方式

![](https://images.gitbook.cn/0wEVpp)

异步方式通道本身是个数据槽，我们可以定义数据槽数量。

发送方发送数据，发送方首先检查数据槽有没有空位，如果有空位直接把数据放进数据槽，然后返回，不需要等待接收方。

同样的接收方检查数据槽有数据直接把数据取走，它不需要等待发送方。

如果发送方检查数据槽满了，那么发送方把自己放到等待队列中，发送方会阻塞，所有发送方都在发送队列排队。这时接收方到达，数据槽满了情况下接收方取走任意数据就有一个空位，确保有一个空槽。然后接收方向发送方等待队列发送一个信号通知有空槽，至于队列中哪个发送方来填空槽和接收方没关系，接收方只负责发送一个信号，接收方是异步的，它不知道发送方是谁。

同样的换个角度来说，接收方发现数据槽是空的。接收方把自己放到队列中等待，无论多少接收方都放进队列中。这时发送方达到，把数据放进数据槽，这时发送方向接收方队列发送有数据信号，同样的发送方也不知道具体的接收方是谁。

发送方在排队，接收方到达时，它先检查发送方队列，当发送方有排队意味数据槽是满的，先从数据槽取数据，再把数据填进取走的空位置，通道的基本规则是数据是有序的。

所以异步方式，发送方和接收方都是围绕数据槽进行操作，如果数据槽有空位或者有数据，发送方和接收方是异步操作。数据槽满的情况下发送方阻塞，数据槽空的情况下接收方阻塞。无论是取数据还是放数据都有责任唤醒另一方的等待队列，最后谁激活和另一方没关系。所以异步方式围绕是槽，如果槽的数量是零就是同步方式。同步与异步的区别是数据通过数据槽交换还是直接交换。

数据通过数据槽传递会导致二次拷贝。发送方首先会检查有没有排队，有排队数据槽肯定是空的。数据不需要放到数据槽直接发给接收方，两次拷贝变成一次拷贝，简化算法提升性能。

所谓异步方式同样存在阻塞的可能。数据槽也不是越大越好，非常大会占用很大的内存。另外对数据槽操作都会加锁，如果发送方和接收方对数据槽检查过于密集会导致锁竞争非常激烈。如果发送方过快，应该考虑提高接收方单次处理能力，或者把一条通道变成多条通道。

#### 例子

    
    
    func main() {c := make(chan int, 5)
        go func() {println(<-c)
            // println(<-c)
            // println(<-c)
        }()
        c <- 1
        c <- 2
        c <- 3
    }
    

上面例子是异步方式。数据槽有五个放了三个数据，还有两个数据没处理而已。异步方式不需要等待另一方，任务单元只处理一个数据，两边的逻辑合理，剩下两个数据有没有处理不关心。

`c <- 1` 是把数据放到数据槽中，不需要等待接收方。`<-c`
表示接收方取数据，如果数据槽没有数据接收方排队。如果编码中没有发送方从排队队列唤醒接收方会死锁。

#### 小结

我们用送快递的例子很好的理解通道的工作原理。通道在细节上做了一些优化，比如减少数据复制，减少中间操作环节，都是值得借鉴学习的。通过通道，传递不是数据而是数据的控制权。值传递是复制一份控制权，指针传递是需要考虑数据放到通道后立即解除数据的控制权，不要引用这份指针。因为发送方和接收方同时持有指针就同时有控制权，应该解除发送方对于数据的持有，指针作用是避免数据复制的开销。发送方可以换个身份作为接收方重新拿回数据控制权。一旦移交数据控制权就不应该继续持有。

**如果转移数据可以为多个人持有的话只有两种可能，第一数据被复制。**

传递的数据也可以是函数，传递函数的指针，双方都可以通过指针执行函数，通过函数中内部逻辑申请控制权。也就是通过通道传递数据逻辑，双方都持有这份数据逻辑，至于逻辑内部怎么处理是内部逻辑的问题，而不是双方关心的。把数据转换成逻辑进行传递，逻辑是一个函数指针，函数本身是只读的，函数内部处理是逻辑的事，不管是发送方还是接收方都不用考虑。

无论是同步方式还是异步方式都是数据的复制。无非同步方式是在发送方和接收方进行复制，异步方式是在数据槽中进行复制。通道本质上是抽象的概念，它的底层就是对数据的操作。

从汇编角度所有的东西都是数据操作，就是数据从一个地方搬到另外一个地方。一种方式通过地址总线在不同的内存段进行搬移，另外一种方式通过网卡或者文件进行搬移，无非就是把数据抽象成不同的状态，模型本身可以被放大。如果把复制操作从内存复制改成从网络复制就实现跨机器了，这种消息通讯是内存的话可以通过信号量实现，如果是网络的话可以通过
UDP 或者 TCP 实现。

任意一个模型和实现没有关系，模型具体怎么实现和需求有关系，但是模型本身可以抽象成架构，实现多个版本，例如进程内的 IPC 实现，跨机器的 RPC
实现，你也通过 MQ 来实现，MQ 可以看作 RPC，RPC 也可以进化成
Restful。架构模型和具体实现是两码事，架构模型需要抛开技术本身从逻辑上保证能够工作。比如异步方式有数据和没数据时进入等待，等待时必须有另一方唤醒，否则一直处于休眠状态。

消息队列一般都是异步的。把数据丢到 mq、kafka、redis 里面，生产端不用关心消费端。在进程内通信有两种方式，异步方式是不关心，同步方式是关心。

### 通道的使用场景

A 和 B 之间有个通道，这个通道假设用来做消息通知的，通知 B 不用等待可以结束，产生 Done 事件。A 把事件发送出去以后，必须确认 B
收到这个消息，否则这个事件发出去以后 A 没法知道是否该结束。为什么传递这个消息就是告诉 B 可以中止，中止完 A 就退出。

  1. 同步通道

不等待 goroutine 通知结束直接退出程序会造成 goroutine 是否执行。之前等待 goroutine 结束使用 `WaitGroup`
计数器实现。下面一个例子用通道实现。

启动一个 goroutine，如果不等待 goroutine，goroutine
没执行也不确定。最好的方式是从通道里尝试接收一个信号一直阻塞等待通知，有信号则退出、没信号则一直阻塞。goroutine
执行结束向通道发送数据，外面一直等待信号。显然这个通道是同步通道，它们之间是交互作用。

    
    
    func main() {done := make(chan bool)
    
        go func() {
            for i := 0; i < 10; i++ {println(i)
            }
    
            done <- true // 向通道发送完成数据
        }()<-done // blocking until event/signal}
    

A 和 B 的同步通信机制是这样的，当 A 准备发送数据不是把数据传给 B，而是试图找到消费方通知有数据。这时主动权由 B 完成，B
首先取走数据，可能是取走控制权也可能拷贝，其次完成自己的逻辑，最后通知 A 结束。同步方式下并不需要存储数据，只需找到对方把数据交给对方。

举个例子，你需要送份信给另外一个人，你拿着这份信站在约定好的地方，这个约定好的地方就是某个命名通道，因为 A 和 B 之间通过命名通道实现的，都是用的
`done` 通道。A 拿着信站在指定的路口，一直等在那，等到 B 来取。B 走过来拿走了 A 的数据，确认这份数据是它要的，在没有确认之前 A
并不能结束。因为 B 取数据可能会失败的。

当然在单个进程内这种情况很少见，对于 CSP 模型 B 如果没有完成某种操作，很多 ack 要求 B 拿到信之后给我一个信号确认拿到这份数据。这时候 A
的行为受 B 的管控，所以它们之间是同步的。这样的流程必须完整的完成。我们通常把这种方式叫做同步方式。显然同步方式更多时候用来传递信号，协调行为。就是 A
拿到数据 B 要实时处理。

同步方式更多时候是把 A 和 B 编排成一个事务。这种事务并不是原子事务，而是 A 和 B 之间操作存在先后顺序。A 因为产生事件 B 处理完事件然后给 A
回执让 A 结束。

利用同步方式来编排。让 A 和 B 交叉执行，A 和 B 都去执行打印输出，如果不做协调我们很难知道 A 和 B 谁先完成。无法知道 A 和 B
谁先执行或者以什么方式执行。

    
    
    func channelSynchronize2() {
    
        // 协调、编排
        a := make(chan bool)
        b := make(chan bool)
    
        go func() {
            for i := 0; i < 10; i++ {
                <-a // 等待信号
                println("A", i)
                b <- true // 发送信号
            }
        }()go func() {
            for i := 0; i < 10; i++ {
                <-b // 等待信号
                println("B", i)
                a <- true // 发送信号
            }
        }()a <- true // 发送信号}
    

我们通过通道做信号控制，这很显然是一种同步方式，用来在不同并发单元之间进行任务编排，这是很常见的使用案例。同步方式最常见的使用除了单向发送信号以外，有些时候我们会使用同步通道在不同任务之间进行编排，例如
A 生产一个 B 立即处理一个，同步方式决定了 A 和 B 两个并发单元之前存在一种任务编排关系。

还有一种称之为异步的，和日常开发消息队列非常相似的，同步方式并没有数据容器之说，只需要把自己的数据传递给对方就可以了，A 和 B
之间有关联关系，只要转移数据控制权就可以了，数据放在哪通道并不关心，通道关心的是把 A 和 B 建立联系。

异步方式最重要问题是传递数据，所谓的异步通道相当于存储柜，A 到达存储柜，如果存储柜有空地，就把数据放到空地上，放完以后立即回去，接下来与 A 无关。B
只要发现柜子有数据就把数据拿回去。所以异步方式 A 和 B 只关心数据，谁存的谁取的没关系。同步方式 A 和 B 必须见面，异步方式 A 和 B
不需要见面，而且把数据放到后立即走人，B 取数据也立即走人，A 和 B 之间不存在先后问题。

可能出现另外一种情况，A 和 B 在异步方式下也存在同步问题，A 有空位子把数据放进去就可以了，来了没有空位子，数据是满的，它会把自己放到等待队列里去，A
实际上处于阻塞状态。异步方式同样会阻塞，因为数据槽满了，消费端发现有数据，拿走其中一份数据，空出一个块，就往等待队列发送一个信号，立马走人。因为谁往里面放数据跟
B 没有关系。这时候本地队列按照先进先出顺序把数据放回空槽里面去。说白了 A 和 B 之间依然存在通知机制，只不过 B 在发送通知时候根本不需要知道 A
是谁，只需要往等待队列里面发送信号。

反过来还有另外一种状况，B 是接收方过来以后发现一个数据都没有，B 就处于阻塞状态，因为数据槽是空的，B 也在等待队列等，A
过来放份数据，就有数据了，往本地队列发送信号，B 就出来拿数据。

异步方式争夺的是数据槽，分为有数据和没数据两种状态，有数据和没数据情况下双方都可能处于等待队列的情况同样也会阻塞。所谓的异步方式指的是在有数据槽或者有数据的情况下生产方和消费方的行为不需要等待另外一方，但是在没有数据或者没有空槽的情况下需要阻塞实际上需要等待另外一方发送一个行为通知告诉可以发送数据或者取数据，但是
A 和 B 之间不需要构建一种耦合关联关系。

异步方式的特点是当数据槽没有满的情况下可以快速的做多次生产操作直到把数据槽填满，也就是说在填满之前生产端不需要考虑消费端的速度，生产端可以完成一次批操作把数据填满。同样消费端也可以完成一次批操作不关心生产端生产，可以快速消费数据槽里面所有数据，不需要关心生产端状态，这时候生产端消费处于一种批操作。所以在多数情况下，异步方式可以提升处理效率，生产端消费端可以充分发挥自己的计算能力。

我们现在知道了同步方式与异步方式有什么不同，很显然，异步方式倾向于数据处理，同步方式倾向于多个并发任务之间协调。

例如异步方式有专门传递数据的通道，缓冲槽设置为
5。传递数据类型可能是整数也可能是复合类型，如果是超大类型的数据可能是指针，传递指针不分同步还是异步的，主要看数据量是否大，复制是否合算。

    
    
    func channelAsynchronous() {data := make(chan int, 5)
    
        // 消费数据，循环取数据
        go func() {
            for x := range data {fmt.Println(x)
            }
        }()
    
        // 生产数据
        for i := 0; i < 10; i++ {
            data <- i
            fmt.Println("send:", i)
        }
    
        close(data)
    }
    

在没有消费的情况下可以发送 5 份数据。生产数据 10
份就结束了，但是消费端并不知道什么时候结束，通常情况下生产数据结束之后通知通道关闭，关闭通道也是一种通知。消费端就知道通道关闭不会生产新的数据。

例如下面的代码有死锁问题

同步通道发送的时候，拿上 100 这个数据就一直等着，也就意味着下面的代码永远不会执行，当前处于同一个执行序下面。

    
    
    func channelDeadlock() {data := make(chan int)
    
        data <- 100 // 100: blocking...
        x := <-data
    
        println(x)
    }
    

但是改成异步通道就没有问题，异步方式关心的是数据槽，当拿着 100，数据槽里面没数据，把 100 放入数据槽就立马走人，接下来自己拿，有数据也没有问题。

    
    
    func channelSlot() {data := make(chan int, 3)
    
        data <- 100 // 100: 100->slot
        x := <-data
    
        println(x)
    }
    

同步与异步的差异是使用场景不同，同步方式会导致生产端消费端有编排效应，事务效应。生产端消费端从并发并行状态变成串行状态。异步方式只要数据槽没有满或者没有空的情况下可以批操作，这只是站在数据角度，但是更大的不同在于同步方式使用的目的就是用来协调做通知，协调多个并发单元之间的行为，什么时候可以启动什么时候结束什么时候能收到信号什么时候等到生产端完成以后再去执行，这是一种编排。

#### 小结

所以通道可以做下面事情，第一传递数据。第二转移控制权。第三编排先后顺序。第四通过令牌控制并发数量，即信号量。第五通道断开所有排队就全部被释放，可以形成类似广播应用。很多情况下通道可以用来当作消息通道，也可以当作事件通道，通过关闭通道解除所有人的排队。假设接收方和发送方都是运动员在排队通道上，相当于在起跑线上不需要关心多少个只需要控制关闭事件。

### 传递数据

基于消息队列架构或者基于 CSP
通信模型关心的是传递什么。通道的目的是传递数据的控制权，传递数据有几种，第一种是内存的地址，第二种是数据的拷贝，第三种是事件。

    
    
    func channelMode() {go func() {
            // 消费
            for {// 处理数据}
        }()go func() {
            // 生产数据
            // 数据生产完毕通知
        }()}
    

通道用于传递数据，数据通道向里面传递整数，用循环向通道里读数据，另外一方向通道里面发送数据。

    
    
    func channelDataMode() {data := make(chan int)
    
        // 消费
        go func() {
            for x := range data {println(x)
            }
        }()
    
        // 生产
        for i := 0; i < 10; i++ {data <- i}
    }
    

通过在不同并发单位进行数据传递很典型的两种应用。

  * 第一种，传递指针的前提是在同一个进程中，同一个内存空间中大对象。大对象应该避免复制。

  * 第二种，小对象一般直接复制传递，可以避免小对象在堆上产生大量的临时对象对垃圾回收影响会很大，因为数据在通道之间传输肯定分配在堆上，每个并发单元有自己的执行序，数据不可能保留在栈上。

  * 第三种，通道传递信号进行协调。事件也是一种数据，比如生产端和消费端。生产端生产数据消费端处理数据，生产端生产数据发送完毕信号，消费端才知道生产结束，不然一直处于阻塞状态。传统的信号是 EOF 和关闭信号。

所以传递什么数据需要考虑清楚，进程内通道大对象和小对象应该怎么传递。跨进程跨机器建议内部通信使用二进制协议，对外使用文本协议。文本协议传输性能不好，需要解码判断格式，长度也比二进制长。二进制协议不需要格式判断序列化判断，性能很高。一般服务器使用同一种架构，同一种操作系统，它们内存布局是一样的，可直接把二进制数据放入内存，利用指针方式直接操作。这种例子很常见，比如
MySQL，PostgreSQL 处理很多协议，预编译方式会把文本协议转换为二进制操作协议。

#### 数据收发

    
    
    func main() {c := make(chan int, 5)
        go func() {defer close(c)
            x, ok := <-c
            println(x, ok)
            for x := range c {println(x)
            }
        }()
        for i := 0; i < 10; i++ {c <- i}
        <-c
    }
    

> 收发模式基于 ok-idiom 或 range 模式。

有两种方式从通道里接收数据，一种是单步的方式，一种是循环的方式。单步的方式基于 ok-idiom 模式判断数据是否收到。循环的方式基于 range
模式从通道接收数据，通道被关闭时结束循环，否则一直处于死循环的方式。

#### 发送事件

除以数据作为消息载体外，还可关闭通道引发群体性事件。

  * 一次性通知事件，close chan struct{} 更合适，无额外开销。
  * 还可用 sync.Cond 发送单播或广播消息。

下面的例子传递数据完成后把关闭通道，也是正常的使用方式。

    
    
    func main() {
        var wg sync.WaitGroup
    
        // 通道
        data := make(chan int, 3)
        wg.Add(1) // 计数器加上一
    
        // 消费端接收数据
        go func() {defer wg.Done() // 计数器减去一
    
            for x := range data { //break closed
                fmt.Println(x)
            }
        }()
        // 生产端发送数据
        for i := 0; i < 10; i++ {data <- i}
        // 关闭通道
        close(data)
    
        wg.Wait()// 等待计数器结束}
    

  * 第一种方式是一次性通知。通道一旦关闭，不能把关闭的通道重新打开，所以关闭通道只处理一件事情。关闭通道不关心传递的数据，可以声明传递一个空结构体，不需要占用额外内存。

  * 另外一种方式用 `sync.Cond` 发送事件，支持单播和广播，相当于下一个和一次性广播所有。

下面的例子创建一个任务单元每隔一秒打印当前时间，使用布尔值或者字节传递信号。首先创建通道用于传递事件，`<- exit` 用于接收信号，接收信号后立即退出。

    
    
    func channelEventMode() {
    
        // 创建结束通道 作为传递事件
        exit := make(chan bool)
    
        go func() {
            for {time.Sleep(time.Second)
                fmt.Println(time.Now())
    
                <- exit // 这种格式 接收信号，只要接收到这个信号就立即退出 (从通道数据往外读，读到左边)
            }
        }()time.Sleep(time.Second * 10)
        exit <- true //10s 以后 发送信号，(exit 是通道，数据往里面写，写到左边)
    }
    

上面例子的代码不严谨，并发单元一旦接收到信号就退出，如果没有接收到信号不停的循环。

#### 群发事件

    
    
    func main() {
        var wg sync.WaitGroup
        wg.Add(3)
        ready := make(chan struct{})
        for i := 0; i < 3; i++ {go func(id int) {defer wg.Done()
                println(id, ": ready.") // 运动员准备就绪
                <-ready                 // 等待发令
                println(id, ": running...")
            }(i)
        }
        time.Sleep(time.Second)
        println("Ready? Go!")
        close(ready) // Go
        wg.Wait()}
    

当需要等待多个 goroutine 结束使用 `WaitGroup` 比较方便。`WaitGroup` 内部有计数器，`Add`
设定计数器，goroutine 在结束之前调用 `Done` 相当于计数器减一，等待操作 `Wait`
相当于计时器为零解除阻塞，如果计数器不为零则一直等待。

我们可以在很多地方调用 `Wait` 等待操作，这样所有地方都能监控计数器为零解除阻塞达到群发事件作用。

在这个例子中，`ready` 用来引发一次性广播事件，类似运动员起跑枪声，`WaitGroup` 明确等待多少个结束。创建三个 goroutine
相当于三个运动员，等待 ready 信号。

**有几种方式等待？**

  * 第一种方式用通道传递数据，每个并发单元拿到一个令牌，这样有先后次序，因为在通道中获取数据加锁解锁有延迟。

  * 第二种方式用通道发送广播事件，所有并发单元收到广播事件。广播事件有两种类型，第一种类型是一次性事件 `close()`，每个并发单元都能收到，第二种方式是 `WaitGroup` 等待有多少并发单元结束。

假设不用 `WaitGroup` 而用 `ready` 实现等待操作，则需要把通道包装成信号量，但是通道的双向编排效应实现等待没有计数器实现方便。

官方建议使用通信的方式来代替共享，并不是鼓励使用通道，通信不等于通道，通信可能是一个函数。原子操作需要维持两个逻辑之间互斥，而不是维持数据，数据是未知、逻辑是已知的，原子操作不是处理数据竞争而是处理逻辑竞争。原子操作控制权时间片非常短。

逻辑上互斥使用原子操作更方便，引发消息和数据使用通道更方便。原子操作和通道的使用场景不同，不存在相互替代作用。

### 关闭通道

正常情况下，建议由发送方关闭数据通道。

  * 向 closed chan 发送数据，引发 panic。
  * 从 closed chan 接收数据，返回缓存数据或零值。
  * 无论收发，nil chan 都会引发阻塞。

关闭通道除了引发事件以外。接收方死循环，关闭通道可以退出死循环，即引发让对方退出的事件。通常建议由发送方关闭通道，因为在发送方接收方模型下，接收方不知道有多少数量，但是有时是发送方，比如序列生成器由接收方决定需要多少。

关闭通道有两种方式，第一种方式是消费方关闭，发送方会引发错误，因为不知道通道被关闭。第二种方式是向发送方先处理请求，再决定是否关闭通道。

通道处理数据时，有几个需要注意的项。如果通道已经关闭，发送数据会引发
panic。从关闭的通道接收数据，需要考虑缓冲区有没有数据，有数据返回缓冲数据，没有数据返回零值。如果通道是
nil，也就是不存在，引发阻塞，在编码模型上，要配合 select 语句使用。

**例子 1:**

    
    
    func main() {c := make(chan int, 3)
        c <- 10
        c <- 20
        close(c)
        for i := 0; i < cap(c)+1; i++ {
            x, ok := <-c
            println(i, ":", ok, x)
        }
    }
    

通道放两个数据之后关闭，虽然通道被关闭，可以通过 OK 方式判断通道是不是被关闭。

**例子 2:**

    
    
    func channelRule2() {done := make(chan struct{})
    
        go func() {
            for i := 0; i < 10; i++ {println(i)
            }
            // 两种方式丢数据，一种空结构对象，还有一种直接把通道关闭
            // 很多时候用 close 既向通道传数据同时又来做结束通知
            close(done)
            //done <- struct{}{}
        }()<-done // 一直等待}
    

如果不关闭通道 `close()`，它会提示死锁，因为不关闭通道，for 循环不会结束，收不到任何信号表示通道已经结束，for
循环就一直阻塞在那等，defer 不会执行，计数器永远不会变成零，`wg.Wait()` 永远阻塞。

生产数据完成后通知通道结束，for
循环会一直把通道里面的数据先处理完，处理完最后一个数据以后，下次取的时候就会发现通道里面有个状态，这个状态提示这个通道里面不可能生产新数据了。因为我们不能向已经关闭的通道里面发送数据，那会出错，这时候
for 循环就会知道不可能再有人往通道里面放数据，所以它会终止循环。

终止完会执行 defer，计数器就会解除，就会正常退出。

通道除了传递数据以外，还可以传递生产结束事件，就是发送方不可能再往通道里面丢数据了。这时候通道就起到两个作用，发送数据和结束通知。

结束通知也可以替代掉 `sync.WaitGroup`。

结束通知不需要传递数据或者传递空数据，通道最好的方式用空结构体。执行操作，操作完关闭通道，从外面接收信号起到等到通道执行结束作用。

### 单向通道

默认为双向，可按逻辑需要转换为单向（接口最小化）。

  * 发送：chan <-；接收：<-chan
  * 可用 make 创建单向通道，但没有意义。
  * 不能将单向转换为双向。
  * 不能在单向通道做逆向操作。
  * 不能 close<-chan 通道。

通道有单向和双向一说，默认情况下生产端消费端都可以传输数据。使用单向通道的意义是逻辑控制，比如在等待信号情况下接收信号，但是往通道中发送数据算什么意思，自己发送自己接收？

我们在设计上基于通道编码。第一单向通道是因为接口最小化。第二创建单向通道没有意义。第三不能把单向转换双向，因为破坏设计，同样单向通道不可能做逆向操作。最后尽可能不要关闭接收通道。

在设计上建议接口最小化的说法。通道默认是双向的，发送方使用通道，实际上对发送方来说接口有污染，因为发送方不需要接收功能。最好的实现方式是发送方和接收方都是单向通道。`chan<-`
用来发送数据，`<-chan` 用来接收数据。

创建单向通道没有意义，因为创建接收通道只能接收不能发送？创建发送通道只能发送不能接收？所以我们创建默认双向通道，转换成单向通道交给不同的方。

不能把单向通道转换为双向通道，发送方转换成接收方没有意义。单向通道只能做单向操作，不能做逆向操作。

单向接收通道，不能关闭，应该尽可能让发送方关闭通道。

    
    
    c := make(chan int)
    r := (chan<- int)(c)
    close(r)
    

保证接口最小化设计上的严谨意味着传递通道传递单向通道。单向通道可以保证对逻辑的控制，双向通道没有把生产消费模型划分清楚。

    
    
    c := make(chan int)
    var send chan<- int = c
    var recv <-chan int = c
    
    
    
    func main() {
        var wg sync.WaitGroup
        wg.Add(2)
        c := make(chan int)
    
        go func(recv <-chan int) {defer wg.Done()
            for x := range recv {println(x)
            }
        }(c)
        go func(send chan<- int) {defer wg.Done()
            defer close(send)
            for i := 0; i < 3; i++ {send <- i}
        }(c)
        wg.Wait()}
    

上面的例子创建了一个双向通道，因为创建单向通道没有意义。传递通道明确区分接收通道和发送通道。一个并发单元用于接收数据一个并发单元用于发送数据。发送方关闭通道让接收方跳出循环，数据的流向控制合理。发送方和接收方对数据的处理方式不同，发送方是组装数据，接收方是拆解数据，都是单一职责。

### 选择

可使用 select“同时”处理多个通道。

  * 随机选择一个可用 case 进行收发。
  * 将已完成通道设为 nil，以阻塞阻止命中。
  * 用 default case 避免 select 整体阻塞。
  * 使用 reflect.Select 动态配置。

Go 提供 select 同时处理多个通道。select 处理多个通道要对应多个 case，一个通道可能被多个 case 使用，每次命中其中一个
case，命中指的是通道可以使用，有重复的通道是随机选中。

**select 实现原理**

select 本身在 goroutine 里执行，每个 case
要么是发送方，要么是接收方，如果有数据处理直接命中，不能处理要么在发送方排队，要么在接收方排队。假设另外一个 goroutine
有处理数据把通道唤醒，select 所在 goroutine 就被唤醒。

从 select 中选择能执行的 case，如果没有就处理 default case，如果没有 default case，就把 select 所在的
goroutine 放到所有 case 的通道中排队阻塞，goroutine 可能是发送方，可能是接收方。只要任何一个通道有数据，就唤醒 select
所在的 goroutine 正常执行。所以原来 goroutine 只在一个通道排队，现在在多个通道排队，谁先有数据处理谁的。select
可能同时混合收发操作。

**select 功能点**

select 确保在可用通道里随机选择，select 保存 case 顺序，每次操作利用洗牌算法实现乱序功能，也就是每次调用 select
都会洗牌形成乱序，然后判断哪个通道能使用。

当一个通道是 nil 就会阻塞，所以通道处理完设置为 nil 也就意味着通道不可用，select 永远不会命中。

有些时候我们要检查 select 能不能用判断 default case 是否执行，select 的原理是 case 通道可以使用则优先执行，所有 case
不命中才会执行 default。

有些时候不知道通道有多少个，具体引用是什么，需要借助于 `reflect.Select` 实现动态创建 select。

**例子**

下面的例子使用 select 处理多个通道的监听，每次只执行一次 case 整个 select 结束，如果所有通道都完成需要使用循环。

    
    
    func main() {c1 := make(chan int)
        c2 := make(chan int)
        done := make(chan struct{})
        go func() {defer close(done)
            select {
            case x, ok := <-c1:
                println("1", x, ok)
            case x := <-c2:
                println("2", x)
            case x := <-c2:
                println("3", x)
                // default:
                // println("default")
            }
        }()
        c2 <- 1
        <-done
    }
    

下面的例子使用使用循环监听信号，所有的通道全部关闭后退出。比如有 a、b、c 三个通道，同时监听这三个信号。

    
    
    func main() {a := make(chan int)
        b := make(chan int)
        c := make(chan int)
    
        go func() {
            for {
                select {
                case x, ok := <-a:
                    if !ok {
                        a = nil
                        break
                    }
                    println(x)
                case x, ok := <-b:
                    if !ok {
                        b = nil
                        break
                    }
                    println(x)
                case x, ok := <-c:
                    // 不 ok 表示通道结束了
                    if !ok {
                        c = nil // 通道为 nil，case 永远不会执行
                        break // 跳出 select
                    }
                    println(x)
                }
    
                // 所有的通道全部关闭
                if a == nil && b == nil && c == nil {println("end.")
                    return
                }
            }
        }()
    
        // 往通道丢数据
        c <- 9
        close(c)
        a <- 11
        close(a)
        b <- 10
        close(b)
    }
    

### 模式

常用编码模式。

  * 以工厂模式创建 goroutine+chan，返回 chan 进行通信。
  * 通道作为并发安全队列，用做 id、key、pool 生成器。
  * 实现信号量(semaphore)。
  * 用于信号 (signal) 捕获。

工厂模式

创建 goroutine 后对它失去控制，不知道什么时候执行也不知道在哪执行，怎么和这个 goroutine 交互呢？

通常写法使用工厂模式，把细节隐藏封装起来。工厂模式同时创建 goroutine 和通道，使用通道与 goroutine
进行通信，返回通道。调用方只需要知道通道并不需要知道
goroutine，返回单向通道只能发送数据或者只能接收数据。调用方拿到通道，向通道中发送消息，不需要知道谁处理。

下面的例子是很常见的工厂模式，定义测试函数，函数中执行一堆任务，我们希望等待这些任务结束。函数中创建并发任务并等待并发任务结束时返回通道，返回通道可以接收等待任务结束。如果通道是双向的情况下，既能接收也能发送数据，如果通道是单向的情况下，只能接收不能发送数据。

    
    
    func test()<-chan struct{} {done := make(chan struct{})
        go func() {println("hello world")
            close(done)
        }()return done}
    
    func main() {done := test()
    
        // do something
    
        <-done
    }
    

所谓工厂模式，就是把一个并发任务和一个事件通道打包，打包的优点是执行函数时并发任务也在执行，同时返回通道知道什么时候结束。

工厂模式习惯的做法是执行结束后使用回调，缺点是注入逻辑代码看上去不优雅，最好的方式是提供通道，结果谁处理不关心，怎么处理也不关心，甚至不处理也不关心，因为不是函数的职责，函数的职责是执行并发任务并输出事件通道。我们监听通道事件知道什么时候结束，函数是一种相对独立的个体，用于内敛的各种行为不会接收任何外部行为，编程中最常见的思想是不要跟外部有交叉成为对方组合的一部分。

控制权在函数里才能内敛，不希望调用方的状态影响函数本身状态就不能分开控制权。我们可以复制调用方的状态然后处理，不要在函数里接收调用方的状态进行逻辑处理。调用方负责处理返回值而不是调用方注入影响函数状态，这实际上和调用方存在交叉关系。不希望是交叉关系而是单向线性关系，单向线性关系在重构时不会获取状态。

在并发设计中核心内容第一是传递的是什么，是事件？是数据？是地址？第二谁持有控制权。

并发安全队列

有些时候我们需要产生并发安全的 id 生成器，除了用锁以外也可以利用通道产生。

    
    
    // 返回单向通道产生整形 id
    func ids() <-chan int {id := make(chan int)
        go func() {
            x := 0
            for {
                // 每次把 x 值拷贝到通道里去
                id <- x
                x++
            }
        }()return id}
    
    func main() {id := ids()
    
        x := <-id
        y := <-id
    
        println(x, y)
    }
    

通道是一个并发的安全队列，可以用它来生成
id、key、对象池。另外通道有数据槽相当于拥有令牌，令牌用来实现信号量。所谓信号量就是必须拿到信号量才能工作，拿不到信号量排队。另外处理信号通常会使用通道。通道的优点是等待消息出现，通道用来获得一个数据，获得一个消息，同时还能实现阻塞。

### 超时

下面例子中一个函数需要执行 4 秒。我们执行这个函数做超时处理，简单的做法是把函数打包成通道，结束时返回事件通知。使用
`time.After(time.Second * 3)` 作为超时操作，After 是多少时间后执行。

    
    
    func testFunc() {time.Sleep(time.Second * 4)
    }
    
    func channelRule6() {
        // 包装返回通知，
        x := func()<-chan struct{} {done := make(chan struct{})
    
            // 执行
            go func() {testFunc()
                close(done)
            }()return done}
    
        select {case <-x():// 等待 x 结束
            println("exec done.")
        case <-time.After(time.Second * 3):// 超时
            println("timeout.")
        }
    }
    

`testFunc` 是很普通的函数，我们没法直接判断超时，但是可以把这个函数包装一下，用单独的 goroutine
执行这个函数，使用通道和函数绑定，如果函数正常结束后向通道里发送关闭信号，调用方从直接调用变成监控通道，如果通道返回发送的信号表示函数正常结束。如果接收到的不是函数发出的信号而是
`<-time.After(time.Second * 3)` 触发的表示超时，`time.After(time.Second * 3)` 也是通道，表示
3 秒之后往通道中发送状态。

不过这里缺点是虽然知道函数超时，但是没有办法让这个函数结束，因为包装函数没有介入函数内只是在函数外部包装一个状态，它只是在函数执行结束时获得一个通知，如果希望
`testFunc` 函数在中途结束需要提供上下文对象 context 在内部处理超时。

Go 编程的特点是不能控制 goroutine。goroutine 被哪个 M、P 执行不知道，如果不介入 goroutine 内部没有办法取消。如果希望
goroutine 函数接收信号，需要传递上下文对象介入函数内，因为不了解函数内部逻辑的情况下找不到安全的取消点。

传统编程中线程可以被取消，但是取消会带来危险因素，因为不知道取消线程时当前是什么状态，比如处于写 IO
操作写到一半取消，是否需要把写一半数据删掉还是写完另一半结束。所以发送取消信号，线程监听信号内部处理。

不管 goroutine
编程还是线程编程，一般情况下不建议强行杀掉一个并发单元，强行杀掉会带来不稳定因素。应该协商对方中止。对方应该暴露接口，通过接口控制它是否结束，由对方决定在什么地方结束。

写并发控制的时候，控制权在谁手上最重要，对于取消控制来说，控制权必须在 `testFunc`
函数上，因为对于它来说知道什么地方取消最安全。双向通道的优点是可以返回一些状态和接收一些状态，函数判断是否取消当前任务，双向通道的作用是通讯。

双向通道很常用，写 Web 调用都是双向的，发送请求返回状态，通过状态码判断结果。

### 优化

通常情况下，异步（缓冲）模式有助于提升数据收发性能。

  * 可将多个数组打包，以减少槽占用，降低锁竞争。
  * 如传递指针，应注意数据竞争(data race)。

理论上异步比同步快，因为通道有数据槽，但是无论是发送还是接收都会有锁。因为操作数据槽必须有锁，接收方可能有排队存在竞争效应。

怎么提高通道的效率？

  * 第一：数据槽放批量数据，把多个数据打包形成批处理，通过一次锁请求拿到一批数据，用单次替换批操作减少数据竞争。比如原来是整形换成数组。批量操作替代单次操作提高处理性能，在很多时候把数据打包形成批量操作是很常见的做法。

  * 第二：如果传递指针，注意数据竞争检查。因为没有转移数据控制权可能带来一些问题。

### 资源泄露

    
    
    func test() {c := make(chan int)
        for i := 0; i < 10; i++ {go func() {<-c}()}}
    func main() {test()
        for {time.Sleep(time.Second)
            runtime.GC()// 强制垃圾回收}
    }
    
    
    
    $ go build && GODEBUG="gctrace=1,schedtrace=1000,scheddetail=1" ./test
    

这个例子里，test 函数创建一个通道，创建十个 goroutine 尝试从通道里取数据。在没有发送数据的情况下，这十个 goroutine
都处于等待状态。当没有发送数据未必形成全局死锁。全局死锁就是所有 goroutine 暂停，但是 main goroutine
没有死，也就是这个进程没有完全死锁。这个时候即使执行垃圾回收也会导致这十个 goroutine 永远处于休眠状态，形成资源泄漏。虽然执行多次垃圾回收，但是
goroutine 一直处于数据接收状态。垃圾回收只能判断数据有没有引用，goroutine
没有死掉，它所占内存没法回收，同时因为没有回收，垃圾回收器每次还得检查它们。

并发编程如果写代码没有形成一种规范，就有可能让某个 goroutine
一直死在那。规范就是先把接收和发送用伪代码写好，形成配对，然后去完善接收和发送的细节，这样就能保证收和发式配对的。很多人代码规模大控制能力非常弱。

#### 发送方资源泄漏

我们提到无论同步方式还是异步方式都会有队列。队列决定了必须有另外一方唤醒才能从队列里解脱出来，如果没有另外一方唤醒，那可能就会出现资源泄露。资源泄露最常见的是
goroutine 泄露，我们通常会把发送和接收分成两个并发单元，如果发送单元被放到队列休眠了，一堆发送单元都在这里休眠没有任何接收方来唤醒，那么这些
goroutine 永远不会结束，这就是资源泄露。这种资源泄露可能觉得无所谓，每个才消耗 2k 内存，但有积累很多的话所有栈空间需要扫描 GC
的根，最后会导致垃圾回收器效率会很低。所以一旦泄露非常严重的时候依然会导致很严重的问题。所以 goroutine 发送和接收的平衡要非常的小心。

下面用一个例子说明资源泄露怎么形成的：

    
    
    func test() {c := make(chan int)
    
        for i := 0; i < 500; i++ {go func() {c <- 1}()  }
    
        // go func() {
        //  for x := range c {
        //      _ = x
        //  }
        // }()}
    
    func main() {test()
    
        for i := 0; i < 60; i++ {runtime.GC()
            time.Sleep(time.Second)
        }
    }
    

这是很简单的测试例子，先创建同步的通道 `c`，然后创建 500 个发送方，没有任何的接收，也就意味着这 500
个发送方都在发送队列中进行休眠，因为没有任何人来唤醒它，这就形成很典型的资源泄露。资源泄露的话垃圾回收器是没有办法的。

    
    
    $ go build -o test leak.go
    $ GODEBUG="gctrace=1,schedtrace=1000,scheddetail=1" ./test
    

输出：

    
    
    SCHED 0ms: gomaxprocs=1 idleprocs=0 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
      P0: status=1 schedtick=504 syscalltick=2 m=3 runqsize=0 gfreecnt=0
      M3: p=0 curg=504 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1
      M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1
      M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      G1: status=4(wait for GC cycle) m=-1 lockedm=-1
      G2: status=4(force gc (idle)) m=-1 lockedm=-1
      G3: status=4(GC sweep wait) m=-1 lockedm=-1
      G4: status=4(chan send) m=-1 lockedm=-1
      G5: status=4(chan send) m=-1 lockedm=-1
      G504: status=2(GC worker (idle)) m=3 lockedm=-1
    gc 1 @0.000s 50%: 0.002+16+0.006 ms clock, 0.002+0/8.7/0+0.006 ms cpu, 0->0->0 MB, 4 MB goal, 1 P (forced)
    

我们可以看到 `status=4(chan send) m=-1 lockedm=-1`，有大量的 goroutine 处于等待发送状态，`gc 1`
垃圾回收器根本没有办法处理这些资源泄露。

怎么样去处理资源泄露呢？对于这个例子，需要有对应的接收方，接收方数量和发送方数量可以是不相等，因为 goroutine
并不关心有多少人发送多少人接收，只要能处理完就可以了。第一种方式需要有接收方，第二种方式发送方可以设计超时，发送的数据如果超过 10s
都没有办法接收的话那么就把 goroutine 结束掉。

    
    
    gc 1 @0.000s 15%: 0.003+0.15+0.003 ms clock, 0.003+0/0.13/0+0.003 ms cpu, 0->0->0 MB, 4 MB goal, 1 P (forced)
    SCHED 0ms: gomaxprocs=1 idleprocs=0 threads=4 spinningthreads=0 idlethreads=2 runqueue=1 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
      P0: status=1 schedtick=750 syscalltick=2 m=3 runqsize=0 gfreecnt=38
      M3: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1
      M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1
      M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      G1: status=1(wait for GC cycle) m=-1 lockedm=-1
      G2: status=4(force gc (idle)) m=-1 lockedm=-1
      G3: status=1(GC sweep wait) m=-1 lockedm=-1
      G4: status=6() m=-1 lockedm=-1
      .........
      G500: status=6() m=-1 lockedm=-1
      G501: status=6() m=-1 lockedm=-1
      G502: status=6() m=-1 lockedm=-1
      G503: status=6() m=-1 lockedm=-1
      G504: status=4(chan receive) m=-1 lockedm=-1
      G505: status=4(GC worker (idle)) m=-1 lockedm=-1
    SCHED 1003ms: gomaxprocs=1 idleprocs=1 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
      P0: status=0 schedtick=802 syscalltick=3 m=-1 runqsize=0 gfreecnt=37
      M3: p=-1 curg=506 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1
      M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=true lockedg=-1
      G1: status=4(sleep) m=-1 lockedm=-1
      G2: status=4(force gc (idle)) m=-1 lockedm=-1
      G3: status=4(GC sweep wait) m=-1 lockedm=-1
    

需要注意一点是，发送和接收必须要配对，至于多个人发送方发送一接收方接收循环没有关系，数量可以不相等，只要最终把所有排队的发送方配对消费完。第二种方式是没有接收方，发送方都有超时，就是发送方可以等，但是等
10s 以后依然没有配对的话那就放弃，这也是一种方式。

