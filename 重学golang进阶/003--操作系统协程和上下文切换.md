---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
首先，我们明确一个观点：程序是用线程来执行的。

### 同步执行序

![](https://images.gitbook.cn/cN26Ts)

如上图用户线程执行的一段时间片，线程从起点 A 开始执行，执行用户代码到终点 B 结束，执行到 C 点（Block）需要执行系统调用，用户线程就会在 C
点阻塞，执行序进入系统内核状态，剩下的时间片在系统内核执行。

执行系统调用是操作系统内核的异步调用，系统内核的时间片是由操作系统提供的内部时间片。系统调用不使用剩下的时间片，在用户线程阻塞，剩下的用户线程的时间片被阻塞造成浪费，根据阻塞的方式有两种处理时间片流程，一种方式阻塞什么都不干，一种方式是向操作系统交还剩下时间片给其他程序或者线程执行，但是这两种方式对进程执行都会造成性能损失。

### 异步执行序

还有一种模式，当线程执行到 C
点执行系统调用被阻塞，异步执行系统调用，剩下来的时间片不交还，执行调度把这段时间片交给其他线程执行。当系统调用完成后利用`select`、`epoll`机制实现线程唤醒，唤醒后把系统调用结果返还线程。这样在同一个线程执行多个并发任务，这些并发任务在用户态完成，和操作系统无关。

例如调用`open`系统调用，重新实现`openAsync`异步版本，这个异步版本是本来被阻塞变成异步调用，这个异步调用向操作系统注册`epoll`事件，告知调度器这个线程暂时被阻塞并已经注册相应的事件，调度器把剩下的时间片执行其他线程。对于操作系统来说，线程
A 和线程 B 是属于一套完整的逻辑，操作系统并不关心，这样完整使用操作系统分配的时间片，没有任何浪费。

### 协程基本原理

由于线程拿到操作系统分配的时间片资源非常宝贵。线程不能把时间片浪费，也不能把没有用完的时间片返还给操作系统，因为长时间返还操作系统可能会降低线程的优先级，操作系统会认为每次给这个线程的时间片都用不完，以后给这个线程的时间片可能会缩短。

为了充分利用时间片，利用异步机制，在用户态实现调度机制把阻塞的时间片执行其他的任务，当任务执行完成时，下次再执行时去检查返回的事件，把事件返回的结果返还给原先任务。

操作系统调度是以系统线程为单位，我们在操作系统之上的用户空间再实现一次调度，把浪费的时间片尽可能执行代码。在用户空间的单个线程中实现多任务调度，这种机制称之为协程。线程的粒度比线程更小，实际是把完整的时间片划分为多个段在线程上执行多个任务。

很明显，协程是串行不是并行，它的执行序是执行 A 任务，当 A 任务阻塞时唤醒 B 任务，B 任务执行结束检查 A
的结果是否有返回，不断的切换实现多任务并发。

#### 协程的优点和缺点

协程有什么优点呢？第一协程不需要做锁处理，例如 A 和 B 都共享变量 x，A 和 B
不需要加锁，因为它们不可能同时执行。第二可以自主实现很多不同调度机制，自主控制控制权。比如 A 执行到一个节点时唤醒 B，或者 B 执行完一个节点时唤醒
A。A 和 B 可以把逻辑执行到相对安全的节点交出去。所以相比较操作系统的抢占机制，协程实现的是协商机制。

不同的调度器实现协程方式也不同，一种实现机制由用户逻辑自主控制，很多语言都有实现，利用`yield`把当前任务暂停交出控制权。一种实现机制是伪调度机制，类似抢占，例如
Python 语言是解释性执行，按指令计数，累计 10 次交出控制权。伪调度机制控制不了时间片，它只是计数器并不知道指令花费时间。一种实现是抢占调度，比如
erlang
语言实现的是抢占，但是跟操作系统抢占有区别。调度毕竟不是由操作系统实现，不能真正意义上做到抢占调度。因为在用户态无法实现向操作系统索要时间片，操作系统是每执行多少毫秒分配时间片，所以用户态和系统态实现调度差别很大。

### 上下文切换

计算机 CPU 核的数量有限，程序执行的任务有很多，所以这会涉及到时间片执行完把状态保存现场，下次执行时恢复现场，这称之为上下文切换 (context
switch)。

上下文切换实际上有以下几种。

  * 操作系统级别
  * 进程级别
  * 线程级别
  * 中断

操作系统级别上下文切换的成本非常高，需要把所有数据保存，比如 CPU 的 L1-L3 缓存，操作系统 mmu 映射关系、相应的 IO
操作、注册的信号、处理的事件等。

进程级别上下文切换，整个进程需要保存现场或者恢复现场。

线程级别上下文切换，因为同一进程共享同一段虚拟地址空间，不用保存 mmu 映射、L1-L3
缓存。当用户线程进入系统线程时上下文切换需要把用户线程的地址映射到系统线程中，类似虚拟地址空间换入换出，需要保存场景和恢复场景。

中断引起的上下文切换，中断是操作系统概念。比如

一种是硬件中断。程序正在执行按`Ctrl+C`操作系统立即会捕获硬件中断信号，操作系统处理中断信号，先把执行任务挂起，判断何时断开。
一种是底层驱动程序引发的被动中断。
一种是系统调用引发的主动中断。系统调用从用户空间进入系统空间，用户空间数据需要保存，因为接下来这个线程用来执行系统级的代码，`.text`段是操作系统代码，执行时可能会覆盖寄存器的数据，所以进入系统调用的时需要把用户态的状态全部保存起来。

#### 上下文切换对性能的影响

无论进程级别、线程级别、主动系统调用引发的上下文切换都会造成一定的性能损失。尽可能的减少系统调用实际上是减少上下文切换造成的性能损失。因为离 CPU
近的资源比如 L 级的 Cache，寄存器数据都要写回到主存，系统代码执行完要把主存数据读回来，相对 CPU 执行速度从主存操作数据非常慢。

我们可以使用一些工具检测这些信息。

`dstat`：监控 system 里 int 中断次数、csw 上下文切换次数。`dstat`监控的是系统级别，进程级别的监控使用`sysstat`包。
`pidstat -w l`：监控进程级别，`-w`用来检测上下文切换每秒百分比，主动 cswch/s，被动 nvcswch/s。
`strace`：检查哪些系统调用，还有 htop，`s`参数用来跟踪系统调用。

数字大可能是系统调用造成上下文切换频繁，考虑减少系统调用次数。比如`IO`操作造成上下文切换，应该考虑在用户空间创建 buffer，数据先写进
buffer，填满再刷到操作系统。上下文切换影响程序性能是很重要的因素。

