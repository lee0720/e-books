---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 上下文

上下文不太好理解，因为上下文在不同地方不同说法显得有点太过于抽象，多数情况下上下文指的是完成一个行为所需要的环境。这个行为可能是一段逻辑，也可能是某一个调用，甚至是进程和线程的切换，甚至是用户空间到系统空间的切换。这个环境可能包含保存寄存器相关的执行信息，这些信息确保行为可以正常执行或者回溯。也就是说在不同的场合有明确的定义，但是我们很难把它具象化，需要根据上下文来判断上下文。就
context 这个词来说我们没有办法给他明确的定义。

这里的上下文更像设计上的东西，不属于抽象的概念，指的是在链式调用当中需要传递的信息。链式调用通常指的是某个过程。比如 ABC
调用的过程当中，需要传递的一些信息，这个信息通常称之为上下文对象。

在 Web 框架中最常见的上下文对象是 Request 和 Response，很多 Web 框架把 Request 和
Response，可能包含其他的参数处理的对象封装起来，称之为一个上下文对象。

如果链式调用是汽车装配线的话，对于单个请求，它的上下文可能是装配线上正在装配的汽车，这个汽车顺着传送带向不同的工位进行传送，不同的工位会对这个上下文对象做出不同的调整。

这样一来整个逻辑是由两部分组成，第一种是行为，就是这条汽车装配线，如果汽车装配线上没有汽车，这条装配线只是一个流程，正因为上面有了汽车，这个逻辑才具备了状态，具备了在某个物理时间点上完成某项操作，这个时候这种上下文更像一种设计模式，把行为和算法，实际上逻辑很多时候是算法，算法把数据分离开。算法是一堆函数链式调用，数据是上下文对象，上下文对象沿着链去传输，最后每个链环节只需要完成对这个上下文对象某一次加工，然后立马失去状态不再持有状态，这是很常见的应用，把数据和逻辑分离。数据打成包，这个包可能称为上下文，里面有需要的请求参数和返回信息，这个上下文对象沿着处理过程依次调用。

Go 专门设计了上下文，更大的体现在对链式调用管理上。它分为几种，第一种是取消，第二种是超时，第三种是传值。

一个链
a、b、c，用不同上下文去传递。这个上下文未必是同一个上下文，可能某个地方创建新的上下文并且把原来上下文包含进来。可能在某个点上执行一次取消操作，按照流式管理来说后面的节点都应该取消掉然后立即返回到上级节点。还有一种在
b 执行超时管控，如果发现 c 包括后面调用超出设定的时间，应该忽略掉 c
的结果直接返回调用方或者上一级告诉调用方因为某种原因超时。超时也是一种取消操作，区别在于前面是主动取消，第二种超时相对来说被动一点，超出一个阈值才会取消。第三种我们可以沿着链式调用传值，在
b 设置 keyvalue 值，在 c 可以读到，这其实是沿着链式调用传递新的状态。基本上官方设计就是这样过程。

通常情况下上下文通过第一个参数传递，关键是保证沿着链所有环节可以访问。官方上下文提供一个根，从某个地方开始，Background()
其实创建空的上下文，里面什么都没有，但是可以成为链式调用上下文的根。

我们初步完成一个链式，从 A 开始调用，给 A 传一个空的上下文。在 A 中拿到就是 ctx 上下文。正常情况下 A 调用 B、B 调用 C
形成一个链式调用。C 完成一个操作。比如在 C 中模拟时间比较长的操作。

#### **传值方式**

从最简单的传值开始，比如 A
需要向后面传递一个值，保证链式调用都可以访问到。我们创建一个上下文，这个上下文可以基于当前上下文进行包装，指定指定父上下文，父上下文从参数上去拿。然后指定一个
Key。需要注意的是上下文传值，每个地方只能用一个，也可以进行多次嵌套，这样就得到一个新的上下文，这个新的上下文是对原来上下文的包装。如果要多的话可以继续增加新的。B
如果不做任何改变，它可以继续向后面传。在 C 可以读到这个数据。

查找实际上是一个递归查找过程。因为它的值可能会被修改。比如 B 重新包装一个新的值 1234。我们取到的总是离自己最近的值。这是传值方式。

    
    
    func a(ctx context.Context) {
        ctx = context.WithValue(ctx, "a", "hello world!")
        b(ctx)
    }
    
    func b(ctx context.Context) {
        ctx = context.WithValue(ctx, "a", 1234)
        c(ctx)
    }
    
    func c(ctx context.Context) {
        //模拟操作
        time.Sleep(time.Second * 2)
        //可以读到数据
        fmt.Println("c exec.", ctx.Value("a"))
    }
    
    func main() {
        a(context.Background())
    }
    

#### **超时方式**

除了传值方式以外，还有最常见的操作是超时。b 调用 c，假设 c 执行 db
查询操作，可能花很长时间，但是对客户端来说不可能等很长时间。超时操作在很多时候都会用到，我们怎么样控制超时呢？

我们通过上下文设置超时，我们可以用 WithDealine 和 WithTimeout 定义超时操作，它们的参数不同，WithDealine
给一个确切的自然时间，WithTimeout 给一个多长时间片段。

我们基于当前上下文定义一个超时的时间，比如超出一秒就认为超时。定义超时上下文返回两个参数，一个参数是上下文对象，另外一个参数返回一个函数
cancel，这个函数可以主动调用的。主动调用这个函数就是主动的取消后续调用。我们利用自动超时方式检查，可以用 ctx.Deadline()
检测超时操作，这个函数返回两个值，第 1 个是绝对的超时时间，第 2
个是是否设置了超时。通常是要来判断什么时间超时，但不能返回是否已经超时，需要和当前时间进行比对。

我们判断超时是通过 select 接收信号，ctx 的 Done() 是一个管道，如果超时这个管道就会被关闭，Err() 错误值是什么原因超时。

目前代码 c 是完整执行。后面只是通过接收一个信号判断是否超时，并没有对这个超时作出处理。因为函数 c 是阻塞调用的。

正常情况下需要把 c 放到单独的并发单元里运行。为了知道 c 有没有完成，应该返回一个通道，如果执行结束关闭这个通道。把函数 c
包装用并发单元执行，形成一次异步调用，不阻塞当前程序。然后通过接收通道事件可以知道这个方法是否结束。在 select 中如果先接收到通道信号，表示 c
在超时之前完成；如果 Done 先接收信号，表示超时信号收到。通过这样可以知道谁先完成。

    
    
    func a(ctx context.Context) {
        b(ctx)
    }
    
    func b(ctx context.Context) {
        //基于当前上下文定义一个超时时间，如果超出 3s 认为超时
        ctx, _ = context.WithTimeout(ctx, time.Second *3)
    
        //异步调用不会阻塞当前程序，然后通过接收通道事件
        done := make(chan struct{})
        go func() {
            defer close(done)
            c(ctx) //db query
        }()
    
        //检测到超时操作
        fmt.Println(ctx.Deadline())
    
        //判断超时
        select {
        //如果超时信号先收到，表示超时之前没有完成
        case <-ctx.Done():
            fmt.Println("timeout, ", ctx.Err())
        //如果先收到消息，表示程序在超时之前就完成了
        case <-done:
            fmt.Println("exec done.")
        }
    }
    
    func c(ctx context.Context) {
        time.Sleep(time.Second * 2) //2 秒后
        fmt.Println("c exec.")
    }
    
    func main() {
        a(context.Background())
    }
    

我们可以看到上下文并不能管控程序的执行，它只是提供一套辅助机制来判断是否达到了某个临界值。

通过这样处理，我们可以判断在一次链式调用中是否有超时。通过上下文传递我们可以处理相关辅助开发。

#### **取消方式**

定义一个可以被取消的上下文，它返回两个值，一个是上下文，一个是方法。通过这个方法可以取消调用。我们可能是一个并发单元放入逻辑中检查某些条件调用取消操作。

我们在 b 和 c 输出一个值。从上下文中读出一个信息，直接判断 OK。通过 OK 判断是被取消，因为读取失败没有阻塞。

    
    
    func a(ctx context.Context) {
        //定义可以被取消的上下文
        ctx, cancel := context.WithCancel(ctx)
        //假设提前调用取消操作，当然放入逻辑里面，可能是单独的 goroutine 检查某些条件
        cancel()
        b(ctx)
    }
    
    func b(ctx context.Context) {
        c(ctx)
    
        _, ok := <-ctx.Done()
        fmt.Println("b:", ok)
    }
    
    func c(ctx context.Context) {
        //模拟 c 是否可以检测到取消
        _, ok := <-ctx.Done()
        //ok 读取失败，说明是被取消的
        fmt.Println("c:", ok)
    }
    
    func main() {
        a(context.Background())
    }
    

当我们在某个节点上执行对上下文的操作，它会沿着调用链向后传输，有点像 js 的事件传递机制沿着 dom
树向下传递，但是对上级收不到取消操作，因为取消操作是取消后面的操作没有办法取消前面的操作，前面的操作发生在取消之前取消它没有任何意义，所以只有在后续的环节收到取消操作信号的时候才可以决定是否要执行后面的操作，因为后续环节在执行之前先判断是否被取消，然后去决定有没有必要执行后面的正常逻辑。

### 源码解读

接下来我们看下上下文怎么实现的？这些信号怎么传递的？涉及源码层面。上下文接口比较简单，它实现了几个方法。

Deadline() 用来判断当前上下文是否设置了过期时间，ok 返回值是否设置了过期时间，如果设置的话这个过期时间是什么时候，deadline
代表的是绝对时间。

有些时候在链式调用中用来检查是否值得调用，在某点检查是否设置了过期时间，如果设置了过期时间，检查离过期时间还剩多少时间，评估后面调用可能超出这个时间，这时候就不再调用后面调用直接返回。比如
A 调用 B，B
过期时间还有多长，如果过期时间剩下两秒，但是后面的调用需要的时间超出两秒，这个调用实际上没有什么意义，就算执行完成也会忽略的，通过这个判断是否值得完成后续调用，如果不值得调用直接返回。

Done() 是只读的单向管道，通过它可以判断上下文是否被取消，如果被取消后面就不需要执行了。用来传递信号通知的。

Err() 返回的是因为什么原因取消的。可能主动调用了 cancel 操作，也可能是设置了超时时间，在标准库里面只设置了两种可能，Canceled 和
DealineExceeded。如果自定义上下文对象可以定义其他的方式，只要实现接口就可以了。

Value() 用来处理设置状态值的，可以向下传递。

我们可以从 Background 开始，从 A、C、D
这条链上我们可以传递同一个上下文对象，如果修改的话，必须基于上一个上下文创建新的上下文，构成这种继承关系。

Background 就是一个空的一个上下文，什么都不干。大多数情况下，Background
在整个调用链的过程作为一个根。其他的各个节点在根之上累加一些相关的状态。对于我们来说常见两个操作，第一个取消，第二个超时，它会沿着调用链对后续进行广播。

TODO 也是上下文对象，就是临时占位的。

### Cancel

Cancel 结构不太复杂，使用嵌入字段 Context 存储 parent，基于某个上下文扩展，必须存储上一级，done
是一个通道，取消操作时候用它发送一个信号，children 用一个 map 保存所有子节点，信号传递的时候，比如引发取消操作，需要有办法找到后续链，所以用
map 记录下一级节点，下一级也会有自己的 map 记录它的下一级，这样我们通过递归的手段就能找到所有的子节点。

创建对象的时候很简单，把 parent 赋值给
Context，再创建一个管道，其他的变量在需要的时候按需创建，这地方特殊的地方在于当创建的时候怎么样增加子节点。

parent.Done() 首先检查父节点是不是已经结束了，若父节点已经发出了结束的信息那么根本不需要处理，没有任何意义。parentCancelCtx
判断属于哪种类型，`p.err != nil` 如果发出了错误信息，就需要调用子节点取消操作，因为父节点已经开始取消了，如果没有的话把自己添加到父节点的
map 字典里面去。

创建一个上下文流程就是 A 节点有个 context，B 节点创建新的上下文节点，必须把原来的节点作为父节点，这时候它的 parent 就是 A 的
context，同时它会把自己加到 A 的子节点列表中去，这样确保在 A 上发送信号的时候通过 children
字典找到所有需要通知的子节点。构建过程看上去有点像双向链表结构，A 持有 B 和 C 子节点，但是 B 和 C
有个值可以回溯上一级节点，因为在很多时候我们都需要找到链的过程。

接下来当发出取消操作时候，究竟发生什么？创建 Cancel 返回上下文和取消函数。当调用函数会引发结束或者取消通知信号，其他地方通过 Done()
来获取通知信号的。

取消操作怎么做的？首先通过 `err == nil` 判断是否有错误，就是说取消操作首先给个理由。Done()
收到取消通知并不知道什么原因取消的，所以先使用 Done() 来判断是否取消了，Err()
来判断是什么原因取消的，这两个是配对用的，一个是用来接收事件，第二个用来判断是什么原因导致事件发生。所以取消操作必须给出具体的原因，这个原因是通过错误对象提供的，如果
c.err
被赋值过了表示上次被调用过了不能重复调用。第一次完成赋值操作，通道已经被关闭了，不可能对同一个上下文做两次取消操作，只有第一次的取消操作是有意义的。

首先把取消操作原因赋值给
c.err，然后关闭通知管道，管道被关闭其实就是引发一个通知，对方处于阻塞状态会立即解除阻塞。这两步构成了一次完整的取消操作的通知。上面是取消操作的原因，然后发出取消操作的事件通知。

现在只是针对当前自己节点取消，假设现在构成的关系是 A、B、C 级节点这样的结构构成上下文的链，假设在 A 上执行取消操作，发出了事件通知和原因，问题是
B、C
子节点并没有收到，所以必须有个方式让子节点收到。首先遍历所有子节点，调用取消操作，就形成一次递归调用，子节点调用取消操作也会设置相应属性检查它的子节点。这样通过递归调用形成一次对所有深度子节点完整通知过程，这是很典型的递归调用。

在递归调用结束以后，然后把字典置为空，把所有节点移除掉，这实际上也是递归过程。整个的通知过程非常的简单，因为每个节点上有个字典维持它下一级的这种结构。

这种取消操作只能往下传递，它不能往上传递。信号的通知是往下级传递的。

#### **主动调用取消方式**

cancel
调用是我们主动调用取消的函数，调用方式可能用并发单元或者其他的方式决定什么时候取消或由谁取消。甚至可以把这个函数往后传递，在下面某一级调用取消，虽然可以在别的地方调用，但是它绑定的上下文是原来的上下文。不管什么地方调用取消操作，信号引发是从原来地方引起的。上下文定义和上下文取消操作在什么地方调用是两回事。

    
    
    func a(ctx context.Context) {
        ctx, cancel := context.WithCancel(ctx)
        // 包装取消函数
        ctx = context.WithValue(ctx, "cancel", cancel)
        b(ctx)
    }
    
    func b(ctx context.Context) {
        //但是它绑定的上下文是原来的上下文
        cancel := ctx.Value("cancel").(context.CancelFunc)
        cancel()
        c(ctx)
    }
    
    func c(ctx context.Context) {
        _, ok := <-ctx.Done()
        fmt.Println("c:", ok)
    }
    
    func main() {
        a(context.Background())
    }
    

### Timer

这是我们是主动调用取消方法，还有一种方法是通过定时器实现取消上下文，它和取消上下文非常类似，区别在于它把 cancelCtx 作为
parent，然后内部有个定时器实现超时操作，我们创建时候有两种方式，一种给绝对的超时时间，还有一种给相对时间，相对时间就是现在加上某个时间段，加完结果也是绝对时间。

到底怎么实现？首先通过 parent.Deadline() 检查 parent
是否设置了过期时间，如果已经设置过了而且过期时间比当前的还早，那没有必要再设置了，因为 parent 肯定提前先触发，设置后触发超时没有任何意义。

如果没有接下来构建对象，parent 设置 cancelCtx，因为它本身也是取消操作，只不过取消操作是通过手动调用还是定时器调用，它并不是直接把
parent 放到 cancelCtx 里面而是构建新的 cancel 对象，也就是说没有使用上一级的相关属性，比如 done
管道，很显然后面接收到的是新管道的通知，上一级并没有收到。这是确保信号向下传递而不是向下传递，如果管道是一样的话，执行超时操作，上一级也会感受到，我们要确保信号永远向下传递的时候会创建新的管道。

    
    
    func a(ctx context.Context) {
        ctx, _ = context.WithCancel(ctx)
        //输出指针，管道就是对指针的包装
        fmt.Printf("%p\n", ctx.Done())
        b(ctx)
    }
    
    func b(ctx context.Context) {
        //创建一个新的超时，重新创建新的管道
        ctx, _ = context.WithTimeout(ctx, time.Second)
        fmt.Printf("%p\n", ctx.Done())
        c(ctx)
    }
    
    func c(ctx context.Context) {
        //直接继承上一级的管道，并没有创建新的，所以 c 和 b 是一样的
        fmt.Printf("%p\n", ctx.Done())
        fmt.Println("c")
    }
    
    func main() {
        a(context.Background())
    }
    

用代码演示一下，输出管道的指针，管道其实就是对指针的包装。在 A、B、C 通过输出地址看管道有什么不同，我们注意到 A 和 B 的管道地址不一样，我们在 A
创建一个管道，在 B 重新创建新的管道，在 C 直接继承上一级的管道没有创建新的。所以 C 的管道和 B 的管道是一样，通过地址我们可以看到。这样保证如果在
B 执行超时操作，后面通过这个管道接收超时信号的时候只能从 B 和下级传递过程收到信号。A 收不到，因为它们管道不一样。这样确保信号永远是向下传递。

回到源码，接着向后，计算绝对超时时间，和当前时间进行比较，如果小于等于 0 肯定已经超时，后面就手动调用取消操作，不需要用定时器实现了。

如果没有的话，它设定一个定时器，这个定时器给它一个函数，到了时间以后就执行取消操作。无非原来手动调用现在变成自动调用，区别在于给的理由不同，它的理由是超时。超过我们设定的时间了。手动调用给出的理由是取消。

### Value

最后一种是关于读取值操作。如果在 c
中读一个值，那么先查找当前的上下文，如果找不到的话就向上去找，这也是递归过程，区别是往上追溯而不是往下追溯，命中最近的一个就可以了。取消操作是往下广播，而传值操作是往上找直到命中为止。

算法也是递归操作，如果当前 key 相等就直接返回 val，如果不相等就往 parent 查，直到找到 root 为止。

### 例子

比如 b 调用 c，c 是很长时间的 db 查询，那么在 b 可能做几件事情。

    
    
    func a(ctx context.Context) {
        b(ctx)
    }
    
    func b(ctx context.Context) {
    
        //检测时间
        // if t, ok := ctx.Deadline(); ok {
        //  x := t.Sub(time.Now())
        //  if x < 10 {
        //      return
        //  }
        // }
    
        //限制时间
        done := make(chan struct{})
        go func() {
            defer close(done)
            c(ctx) //db query
        }()
        ctx, _ = context.WithTimeout(ctx, time.Second)
        select {
        case <-done:
            fmt.Println("exec done")
        case <-ctx.Done():
            fmt.Println("timeout:", ctx.Err())
        }
    
    }
    
    func c(ctx context.Context) {
        time.Sleep(time.Second * 2)
        fmt.Println("c")
    }
    
    func main() {
        a(context.Background())
    }
    

第一个可以判断上一级节点上是否设置了超时操作，如果设置了就检查 t
时间与当前时间剩下多长时间，考虑值不值得后续这些调用，如果时间小于阈值直接结束调用。这是第一种方式，检查是否设置了超时。如果设置了超时，通过超时时间来判断有没有必要或者值不值得完成后续调用。如果值得就调用不值得就返回。因为我们能预估调用的所花费的成本有多大，每次进行数据数据库查询的代价都挺高的，要建立数据库连接完成查找操作。如果我们平均统计一下单次执行时间，用户可能等不了那么长时间，通过这种方式减少查询次数。如果用户设置最大阈值是
5 毫秒，不用去执行 10 毫秒的调用。这是通过上下文实现过滤的方式。但是我们不知道超时时间是哪级设置的，因为上下文可以往下传递。

另外一种方式必须执行 c 操作，那么可以给它一个预设时间，假设这是搜索引擎的话，搜索引擎其中一条规则是必须 1s 内返回结果超出 1s
没有任何意义。大多数情况下用户不会等待 1s，1s 是这一次完成链式调用阈值。

对 c 做超时！不知道执行时间。但是给定在一秒钟之内不返回直接告诉客户端超时。至于 c
最后结果已经不关心了，这时候我们把阻塞调用变成异步调用，用另外一个并发单元执行长时间操作查询，用管道接收通知，如果结束的话关闭管道来发送结束信号，我们修改上下文处理超时设置
1s。接下来判断谁先收到信号，是上下文信号还是执行完成信号，用 select
方式判断，第一种从管道接收，如果接收到表示结果是有效的，第二种是上下文超时的信号收到，我们打印什么原因超时。因为我们执行 c
操作不知道花费多长时间，在逻辑设计来说认为超出 1s 是没有意义的。所以给出两种判断，第一种 c 在 1s 之内返回了，第二种如果 1s
没有返回必须完成超时过程。

### 小结

这是利用上下文来控制链式调用的执行过程。对于官方设计来说，主要用来控制是否可以主动取消一个操作，这在设计中很常见，因为各种各样的原因一个正常调用卡在那里。第二种设置超时，正常完成调用，但是不知道什么时候完成，给他设置时间限制，还有一种方式通过上下文传值。这是上下文操作中最常见的三种模式。

在写程序中是否使用上下文这种模式控制链式调用过程，这其实更倾向一种设计模式，而不是代码层面上。代码实现起来就是递归调用。

关键是在设计系统时是否使用上下文分离逻辑和数据，用算法把数据和逻辑分离，用上下文承载数据。

用上下文来控制不同节点的行为。在 A 节点发送取消信号，让 C 和 D 取消后续操作。或者在 C 上判断执行 D
的时间，如果不够就不执行，减少调用造成的一些相关资源的浪费。

另外用上下文传递各种各样的一些状态。

  * [How to correctly use context.Context in Go 1.7](https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39#.bp71862ke)
  * [Context and Cancellation of goroutines](http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/)
  * [Pitfalls of context values and how to avoid or mitigate them in Go](https://www.calhoun.io/pitfalls-of-context-values-and-how-to-avoid-or-mitigate-them/)
  * [Context API explained](https://siadat.github.io/post/context)
  * [Context isn’t for cancellation](https://dave.cheney.net/2017/08/20/context-isnt-for-cancellation)
  * [Using context cancellation in Go](https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/)

> **感谢各位的光临哟！！**
> **获取更多资源:掘金小册,gitchat专栏,极客时间等资源；**
> **请到闲鱼店：583128058yanghon**
> **啊呜呜~~~**