---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 动态嵌入

动态除了反射以外，还有另外一种实现方式，就是在程序中直接嵌入 Lua、V8 等动态语言引擎。

大多数语言都有类似嵌入包，比如 Go 语言有 [go-duktape](https://github.com/olebedev/go-duktape)、[otto](https://github.com/robertkrimen/otto)、[golua](https://github.com/aarzilli/golua)、[gopher-
lua](https://github.com/yuin/gopher-lua)。

嵌入 Python 动态语言比较少，因为 Python 引用计数机制比较麻烦，而且 Python 运行时环境太大不是基于嵌入设计。

Lua 本身天生基于嵌入设计的，实现复杂的动态逻辑，直接嵌入动态语言会方便一点。比如 Redis 支持 Lua
的嵌入，优点分离静态部分和动态部分，开发游戏就会严格区分静态部分和动态部分，静态部分是游戏引擎和服务器管理、运营，动态部分是脚本、各种运营活动、相关资源。大多数时候静态部分用
C、C++ 编写，动态部分用 Lua 嵌入。

### 编译

相对于 CPU 来说所有高级语言的语法都很复杂。汇编相对来说非常简单，就是在不同内存之间搬数据，做一些简单累加操作。所以高级语言不能直接交给 CPU
执行，都需要编译。所有动态语言都有编译行为。当源码载入的阶段进行编译，编译结果可能保存到硬盘上，也可能保存到内存中下次重新编译。

具体编译过程就是源文件（.py、.js）用类似 AST
语法解析把高级源码翻译成字节码（bytecode），字节码不是汇编，每种语言的字节码都有相应的规范，比如 C# 规范叫做
MSIL，字节码和硬件平台无关，它是中立的。有的语言不保存字节码，有的语言保存字节码，比如 Java 里面会保存 .class 文件，Python 会保存
PYC 或者 PYO 文件。

接下来二次编译，把字节码编译成机器码，可能是 JIT 把字节码翻译成机器码，也可能是 VM
把字节码翻译成某些函数调用，这个函数是提前写好的完成某个功能，这种方式我们称之为解析。运行期才有解析行为，根据具体平台翻译成机器码。

解析的缺点是每次执行都要解析。JIT 在内存里保存一份缓存，生成类似 .text 段，在硬盘里保存一份缓存，生成类似 EIF
文件。下次解析时首先检查内存有没有，再检查硬盘有没有？用缓存机制避免多次 JIT 编译，所以 JIT 比 VM 解析快很多。

### 栈式虚拟机（Stack-Based VM）

动态语言本身有二次编译，有时可能被隐藏起来，直接解析。高级语言部分称之为前端，编译部分称之为后端，前端主要开发各种各样的功能，开发很多种语言。开发语言的人员只需要关注后端的优化。分离前端优化和后端的优化，提供这种前端和后端平台可以适应未来很长时间的变化。编译就是翻译成字节码就是在不同固定字节码之间组合，字节码是跨平台的，和语言无关、和机器架构无关。接着在运行时需要
JIT 的二次编译或者 VM 的二次解析才能执行。

我们管字节码这种设计模型叫做栈式虚拟机。栈式虚拟机就是所有的调用依次往栈里 push 和 pop
数据。栈式虚拟机可以看成简化版的汇编。因为汇编和具体平台有关系，有些寄存器是某种 CPU 专有的、不同的 CPU
指令也不一样，这就造成汇编要针对某个平台编译。动态语言的字节码和汇编不是一回事，它们的区别没有寄存器。

动态语言把源码编译成和平台无关的字节码，JIT 安装时候必须针对操作系统选择版本，字节码交给 JIT 运行会根据当前环境生成对应机器码。

### 字节码反汇编

字节码针对的是某一类平台，比如基于 JVM、CLR 平台。字节码的规范是由软件厂商定义的，所有基于 JVM
开发的语言生成的字节码是一样。所以可以对其反汇编。

### 类型和对象实例

动态语言的名字只是在名字空间构成引用关系。从名字空间找到对应关系，对应关系找对象，对象头部有类型指针。名字没有类型，只有对象有类型。我们管这种机制叫做弱类型。

### 名字空间

名字空间通常有：

  * globals：模块里面的字典
  * locals：函数内部或者调用栈字典
  * class._dict_
  * instance._dict_

很多语言有专门特殊的模块，这个模块保存所有的内置类型。内置类型有初始化函数、内置的函数、内置的异常、内置的全局变量等。

### 名字查找

名字空间分成 LEGB 四大不同级别，按照这种模式依次寻找，动态语言不能保证变量在哪个级别上，甚至存不存在都不知道。

除了基于调用栈 LEGB 查找方式，还有基于面向对象查找方式，instance -> class -> base
class。首先看是不是实例字段，如果不是看是不是静态字段，静态字段按照继承关系树从子类一级一级往父类查找，如果是多继承，按照从下到上，从左到右规则。

### 动态执行

动态执行方式有：eval、exec、open class。

open class 是开放类类型。比如定义一个类型，这个类型所有成员都保存在名字空间里，可以随时加减字段。

### Decorator、Metaclass

装饰器模型和元类可以修改类型，甚至控制类型的生成。

静态语言更关注的是执行性能，动态语言更关注的是变化能力。

> **感谢各位的光临哟！！**
> **获取更多资源:掘金小册,gitchat专栏,极客时间等资源；**
> **请到闲鱼店：583128058yanghon**
> **啊呜呜~~~**