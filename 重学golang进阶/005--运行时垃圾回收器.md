---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
垃圾回收器相当于程序手动释放内存，从引用计数到现代各种方式，它的理论基础并没有很大差别。

**Go 垃圾回收器源码不适合作为学习的范例。**

垃圾回收消耗最多的时间是扫描对象，看对象是否活着的，是不是有其他对象引用，有引用就是活着的没有引用就是死的。垃圾回收器不关心对象有多大，它关心是对象的数量，也就是对象数量越多垃圾回收扫描时间就会越长，怎么样才能让它每次扫描的数量少一点呢？代龄和垃圾清理两种机制都是为了减少扫描对象数量。

### 引用计数

引用计数是最常见的一种方式，Python 最主要的垃圾回收就是引用计数，早期的微软平台 COM+ 都是引用计数实现垃圾回收。

引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。

引用计数的优点是操作非常的快，减一变成零就是直接手动调用 `free`。实现简单，快速，不需要扫描整个进程空间，它定位的是当前单个对象，效率非常高。

![ndL75a](https://images.gitbook.cn/ndL75a)

缺点 1：易内存泄漏

在早期的 COM+，和现在的 Python
嵌入到其它程序的时候，这个引用计数难于维护，增加引用需要加一，解除引用需要减一，有些时候一不小心忘记或者是内部逻辑很复杂没处理好，造成引用计数数字不平衡引起内存泄露。

缺点 2：不支持循环引用

引用计数缺点是不支持循环引用，循环引用是两个对象 A 和 B，如果 A 引用了 B，B 数字就加一，B 引用了 A，A
数字加一，相互引用这个数字永远都不会为 0，意味着永远释放不了造成内存泄露。如果有 ABCD 四个对象可能会更复杂。

![PP3ugm](https://images.gitbook.cn/PP3ugm)

只有当一个对象引用另外一个对象才会造成循环引用，假如对象是不可变对象，比如整数、字符串，肯定不会引用，不引用情况下，肯定不会造成循环引用。

对象 A 和 B 构成循环引用，引用计数不能回收，但是垃圾回收器可以处理，如果检查 A 和 B 除了它们之间相互引用外没有其他对象引用它们，同时把对象 A
和 B 全部释放。就是说它们之间有引用、对其他对象没引用就释放。

所以 Python 语言提供两套机制，默认情况下引用计数，第二种专门引入了 GC，其实它的 GC
是专门用来处理循环引用的问题。程序里不存在循环引用，可以关闭只保留引用计数提高性能。对于 Python
来说，只有容器类对象才能构成引用，列表、字典、object
是容器类对象，创建对象时在对象头部除了引用计数以外还会有跟踪信息，创建时把跟踪信息加到链表中要做锁处理，释放对象时操作链表影响程序的性能。所有对象的跟踪信息构成链表，GC
扫描这个链表。

有些时候写 Python 语言有这样建议，因为 GC 可临时关闭，假如算法内部肯定不会造成循环引用，可以在进入算法之前把 GC 关闭执行完算法后再把 GC
打开，这样的话也可以优化性能。或者说整个程序可以确保没有循环引用，可以把整个 GC 关闭，因为引用计数机制一直在工作，它优先使用引用计数，然后 GC
是定期的启动。所以 Python 有两套垃圾回收机制。

所以引用计数，引用加一，引用取消减一，引用为零触发回收操作。一旦引用失效，立即释放。引用计数优点是只调整计数器，不需要调用释放，解耦释放操作，因为释放操作涉及控制权的问题。引用计数缺点是引用时维护计数器，经常会漏掉，造成内存泄露，不支持循环引用。

### 析构函数对垃圾回收器的影响

假如对象绑定清理函数或者析构函数，当垃圾回收器准备回收这个对象的时候，它首先把这个对象激活，对象状态从可回收状态变成不可回收状态。因为需要先执行清理函数，执行清理函数时不能保证函数内部有没有引用这个对象，所以需确保这个对象是活着的。即在第一次回收时把对象激活然后执行清理函数，执行后把清理函数解除，在第二次回收时才能正常把这个对象释放。

所以当对象绑定清理函数或者析构函数时，在第二次回收的时候这个对象才会真正被释放，因为它第一次回收时它得保证这个对象是活着的，只有这样它在执行清理函数或者析构函数时才能保证这两个函数执行不会出错，因为我们没有办法保证这两个函数会不会引用这个对象。

那么当一个对象有清理函数或者析构函数时会降低程序整体的性能，建议尽可能不要使用析构函数其实就是对垃圾回收器的影响。

如果对象 A 和 B 构成循环引用，对象内部包含析构函数，则无法判断析构函数谁先优先执行。垃圾回收器即使支持循环引用回收，也会放弃回收引发内存泄露。

### 代龄

代龄机制是最常见的垃圾回收技术，代龄机制代表一定的主流，Java、C#、Python 语言都使用代龄。

代龄机制是这样的，对象通常分成三级代龄 0、1、2。新创建的对象的代龄是 0，每级代龄都有阈值，当 0 级对象数量超过阈值就会启动垃圾回收，垃圾回收扫描所有
0 级代龄对象，扫描完对象是活着或者死着两种状态。理论来说在第一次回收活着对象在第二次回收活着几率很高，垃圾回收器把第一次扫描活着对象标记为 1
级代龄对象，下次扫描 0 级代龄对象不用扫描第一次扫描过的对象，减少扫描对象的数量。当 1 级代龄对象数量超过阈值便扫描 1 级代龄对象，如果 1
级代龄还活着说明这个对象生命周期更长，就标记为 2 级代龄对象。

优点 1: 减少扫描对象数量

通过三级代龄机制可以把长时间活着的对象一点一点的放到 1 级代龄最终放到 2
级代龄，这种长期活着的对象可能在某段时间内死着但是这种频率相对来说很低，我们用这种方式减少每次扫描对象数量。

优点 2: 支持内存压缩

Java、C# 语言支持内存压缩。因为代龄对象的生命周期不同，把 2 级代龄对象统一移到左边，1
级代龄统一移到中间。这样扫描对象只要判断不同代龄区域的开始和结束位置，跳过区域扫描。另外内存区域相对稳定不易碎片化，因为快速创建和快速释放引发碎片化。

代龄机制有很多优势但也有一些限制。

### 标记清理

垃圾回收器另外一种方式是标记清理，标记清理最典型的做法是三色标记。Go 语言用的是标记清理方式，标记清理方式有一些问题。

从根对象开始，垃圾回收分成两个过程，标记和清理。标记是标记哪些是活着对象哪些是死的对象，清理是把死的对象回收。

标记和清理的时候，早期有个问题叫 STW 把世界停掉，停掉后用户代码不会执行，不会产生新的对象，扫描完剩下来是活着的和死的。早期单核 CPU
情况下没有问题，多核所有停下来进行扫描不合理。

#### 标记清理是什么

**白色和灰色对象**
当垃圾回收器第一次启动的时候，它把所有的对象标记成白色，如果这个对象引用了另外一个对象，那么被引用的对象称之为灰色的，把灰色的放入队列，当垃圾回收器第一次扫描完了以后对象就是两种状态，白色的和灰色的，白色的可以释放。

接下来扫描所有灰色的对象，灰色对象从队列里拿出来进行扫描，灰色对象被拿出来以后灰色对象本身被标记为黑色的。如果它引用了其他对象那么这个对象重新变成灰色的，重新放入队列，那么黑色对象肯定是活着的，这样通过一级一级的扫描最终因为灰色对象被放入队列然后灰色对象拿出来进行扫描，灰色对象本身变成黑色的，最终世界里就变成两种对象第一种是活下来黑色的、第二种是所有扫描都没有引用的白色的，那么黑色的都是活着的白色的都是死的。

**根对象**

最早的扫描对象从哪来的呢？生命周期可以保证的对象是根对象。进程里所有的对象都有根对象，根对象有几种，第一种是全局变量，第二种是当前并发任务单元栈。根对象引用堆上对象，堆上对象是活着的，如果没有引用或者以前引用现在没有引用，那么这个对象是死的。线程栈本身就是一个根，线程栈可能引用某个对象的指针。

**标记过程**

从根对象开始扫描，如果全局变量没有引用任何对象，这些全局变量对象肯定可以释放。如果线程栈没有引用任何对象，这些对象肯定可以释放。

从根对象开始扫描所有对象都是白色的，如果根对象有引用，这个对象变成灰色的，依次扫描后只剩下两种对象，白色对象和灰色对象，灰色对象放入队列里。

接下来从队列里把灰色对象取出来，看看灰色对象引用了什么对象，灰色对象本身变成黑色的它肯定活下来的，因为它是被引用才会放入队列的，所以它从灰色变成黑色肯定是活下来的。通过这样把灰色对象一级一级进行递归扫描后最后这个队列被清空了，剩下来的世界只有两种对象，第一种是黑色的肯定被引用过，第二种是没有被引用过的白色对象，黑色活着白色干掉，这就是很典型的三色标记。

标记清理阶段性的扫描，从左往右扫描，找出哪些是活着的，哪些是死的，死的对象回收。如果活着默认情况下称之 G0 对象，就是第一代的。如果第 1
次活着的，就把它放到 G1 里提升对象的生命周期。使用分代是为了缩小每次扫描对象的数量，如果 G1，G2
达到一个阈值重新扫描。垃圾回收还会涉及内存压缩，比如像 Java，C#。Go 语言没有分代，没有内存压缩。

#### 标记阶段举例

我们假设在理想状态下完成一次垃圾回收过程。有 A、B、C、D 对象，根对象引用 A，A 引用
B。在标记阶段，利用三色标记原理，当前堆上所有对象都是白色，接下来通过根对象扫描，A 与根对象引用，回收器把 A 放到队列并 A
变成灰色，灰色对象表示对象活着的有其他对象引用它。接下来 B、C、D 被扫描 B、C、D 都是白色的，因为根对象扫描不到
B、C、D。扫描结束后，所有的灰色对象放到队列里。当第 1 步扫描结束后存在两种对象，白色和灰色。

接下来第 2 步，扫描队列中灰色对象，取出 A 扫描，A 引用了 B，取出 A 变成黑色。B 放到队列里变成灰色，不停地递归，取出 B 扫描，取出 B
变成黑色，队列清空扫描结束。世界只剩下两种对象，白色和黑色，A、B 是黑色，C、D 是白色。黑色对象是活着的，白色对象是死的。标记阶段结束，ABCD 中 A
和 B 是活着，存在着某种关系引用它们。

通过三色标记原理，白色转换成灰色，灰色作为临时的状态，进行递归扫描。在树状结构当中找出所有活着的对象标记黑色，标记结束世界上只有两种对象，白色和黑色，白色的是死的，黑色是活着的。

#### 并发清理阶段

接下来进行并发清理，并发清理和用户代码没有冲突，因为用户代码不引用白色对象，只有黑色对象和用户代码产生关联。

清理阶段真的需要清理吗？比如有内存块位图，每个位置用来存储一个比特位，标记时直接写位图，然后复制这个位图进行反转标记位图就变成分配位图交给分配器。清理阶段只是标记哪些位置可以回收，相对来说效率很高。

#### 写屏障模式

我们大概了解标记清理的基本原理，现在看怎么具体扫描这些对象。

**STW 操作**

早期的做法是在扫描之前执行 STW 操作，STW 简称 `Stop The
World`。运行时把所有的线程全部冻结，暂停所有用户逻辑，所有用户对象都不会被修改了，这时候扫描肯定是安全的，对象要么活的要么死的。所以 STW
操作造成用户逻辑全部暂停，中间暂停时间可能会很长，用户逻辑对于用户的反应就中止了。

因为用户线程被暂停，回收完成后不知道哪个线程先被激活，这会造成原本的用户逻辑没有办法保障，还会造成延迟很高，所以大家对 STW 都比较反感。

**并发清理**

如何减短这个过程呢，STW
过程中有两部分逻辑可以分开处理。我们重点从黑白对象下手，扫描结束后对象只有黑白对象，黑色对象是程序恢复后需要使用的对象，白色对象不会和用户逻辑产生关联，因为白色对象肯定不会被用户线程使用，所以回收白色对象操作实际上可以和用户逻辑并发。

第一步回收操作和用户逻辑可以并发，因为我们回收的是白色对象，扫描后白色对象不会被全局变量引用、线程栈引用。回收白色对象肯定不会对用户线程产生竞争。回收操作可以并发，既然可以和用户逻辑并发，这样回收操作不在
STW 时间段可以进一步缩短 STW 时间。

**并发标记**

垃圾回收器并发扫描对象只读取对象状态不修改对象状态，扫描时用户代码还在执行。垃圾回收器怎么知道对象扫描之后，对象状态发生改变？比如执行用户代码 A
创建新的对象 X、A 引用 X，X 是白色，清理时对象 X 被清理会造成代码逻辑有问题。扫描操作时执行
STW，把一个对象标记为白色的，执行用户逻辑突然引用了它，或者说刚刚扫描的对象正准备回收，结果又创建很多对象，造成扫描状态不稳定。

Go 语言早期扫描操作一直处于 STW 状态，大家对这个抱怨非常的深，就是因为扫描操作要冻结用户的内存状态不冻结没法扫描，后来引入了写屏障的技术。

什么叫写屏障技术，一旦进入垃圾回收状态时进行短暂 STW
暂停，打开标记位标记为正在执行垃圾回收。编译器通过静态分析找到对象内部有指针的行为，有的话编译器自动插入汇编代码用来检查正在执行垃圾回收标记，标记打开说明处于垃圾回收状态，这时对象有指向新对象的行为，汇编代码把这个对象变成黑色对象重新放回队列中，重新放回队列黑色变成灰色则需要重新扫描，从队列取出扫描发现引用对象，把引用对象放到队列变成灰色，然后取出扫描变成黑色。这样通过汇编指令的拦截确保在并发阶段监控不把本来应该活着的对象被回收。

引入屏障技术后，对内存扫描时用户逻辑也可以执行。用户所有新建的对象认为是黑色的，新建对象不用扫描，已经扫描的对象可能因为用户逻辑造成对象状态发生改变，所以对扫描后的对象使用写屏障技术监控用户逻辑，对象发生引用改变就会给写屏障发送一个信号，垃圾回收器捕获到这个信号后就知道这个对象发生改变，重新扫描这个对象，看看它的引用或者被引用是否被改变。

利用状态的重置实现当对象状态发生改变的时候，依然可以判断它是活着的还是死的。扫描操作可以做到一定程度上的并发，但需要在垃圾回收开始时启动 STW
获取状态，没有办法完全屏蔽 STW 可以缩短，现在知道了扫描操作和回收操作都可以用户并发。

编译器一段代码重新二次扫描确保对象标记准确，叫做写屏障。在垃圾回收阶段重新引用另外新对象，这个屏障把这种行为重新过滤，确保两个对象都是合法的。

写屏障技术实现在标记阶段和用户代码并发。

**写屏障带来的问题**

很多人就认为写屏障很好，它单次暂停的时间变短，但是实际上是把单次暂停时间分散了，本来程序执行可能是“用户逻辑、大段
GC、用户逻辑”，分散以后变成了“用户逻辑、小段 GC、用户逻辑、小段
GC、用户逻辑”这样。很难说垃圾回收变快，因为用户逻辑分散后会频繁的保存用户状态，垃圾回收之前要保证用户状态是稳定的，原来只需要保存一次现在需要保存多次。所以
Go 语言提供了一种控制，可以控制是否使用并发扫描，它为什么提供这种控制，需要看用户逻辑更适合哪一种回收方式。

### 辅助回收的作用

如何避免内存膨胀，避免影响性能？

垃圾回收器不处理内存分配只处理内存回收操作，甚至不处理内存回收，它只是告诉内存分配器哪些对象可以被回收，至于内存分配器怎么处理和内存回收器没有关系，它只标记哪些对象活着哪些对象死的。

所以垃圾回收器什么时候启动最合理？如果频繁启动肯定会影响用户逻辑的性能，甚至是在很关键的时候执行垃圾回收。如果不频繁启动或者很长时间启动会造成内存膨胀，不使用的内存一直存在，新分配内存不能重复使用也没被释放，就会造成内存快速膨胀。

有三种方式启动垃圾回收。

第一种方式手工调用强制回收。 第二种方式在堆上内存分配时，统计达到阈值启动，这个阈值默认接近上次两倍。 第三种方式 sysmon
启动，每两分钟检查一次，没有进行垃圾回收就会启动。

比如服务器有突发原因并发量非常大导致内存非常高，高峰期过后垃圾回收，下次回收达不到阈值不触发垃圾回收，长时间不触发垃圾回收导致大量内存闲置。阈值机制失效的情况下，sysmon
检查上次垃圾回收时间，现在时间和上次时间对比超过两分钟，便强制执行垃圾回收。所以第二种和第三种方式是相互配套使用。

使用多少个 CPU 执行垃圾回收？垃圾回收和用户代码并发怎么平衡资源？如果频繁启动或者占有更多 CPU 资源会导致用户代码性能下降。所以垃圾回收器的问题是：

第一，启动频繁导致性能下降。 第二，启动太晚导致内存下降。

闲置大量内存不释放可能导致操作系统性能下降，操作系统只能通过交换分区处理。

垃圾回收器需要在快速回收、阻止内存变大中间找一个合理的阈值，其实是一个中庸的问题，这个阈值必须实现平衡。如果为了快速回收会造成性能问题，如果把频率放慢会造成内存浪费内存膨胀变得很大，这个难题很难解决。现在大部分垃圾回收器都会通过统计调整阈值，怎么调整阈值？

### 控制器的作用

#### 调整阈值

调整代龄的阈值来调整回收的间隔时间，很多语言都是动态调整这些阈值。

Go 语言早期通过静态方式实现，阈值的设定是两倍，后来新增控制器 nextgc
的概念，控制器动态调整阈值。垃圾回收标记阶段收集一些信息，比如执行花费多少时间、占用多少 CPU
时间片。由于不能介入操作系统空间，在用户空间执行时间、CPU
时间片不准。所以基于大量上次统计计算对比动态调整接近理想状态，这是很典型的基于时间局部性的统计。

Go 语言实现动态但相比 Java 语言差的很远，现在很多语言垃圾回收器很难说做的非常的好，因为垃圾回收本身很复杂，所以我们尽可能减少垃圾回收器的负担。

#### 信用授权的机制

Go 语言可能会造成这种状态，扫描的速度跟不上用户分配的速度，会造成扫描永远结束不了，造成内存膨胀，所以必须在性能和内存膨胀之间做出平衡。

比如有 CPU1 和 CPU2。CPU1 执行用户代码，CPU2 执行垃圾回收，CPU2 在标记清理时 CPU1
在非常高密度的内存分配，内存分配的速度远远大于标记的速度，造成垃圾回收的标记任务永远结束不了。

所以回收的速度跟不上分配的速度垃圾回收器会把用户逻辑暂停，用户逻辑暂停后不会有新的对象出现，同时会抢占用户线程进行垃圾回收加快垃圾回收的速度。比如并行四个核，三个核执行用户逻辑一个核执行垃圾回收，变成三个核全部执行垃圾回收。

因为新分配对象比回收快，从并发变成 STW，用户线程被暂停，这种控制叫做辅助回收。

怎么解决这个问题呢，必须有种途径抑制内存分配。垃圾回收有正在垃圾回收标记，进入标记阶段时，内存分配函数检查是否在正在垃圾回收标记，如果标记是打开状态，所有分配操作都要检查信用授权。在垃圾回收阶段进行内存分配，信用值要减去内存分配的数量，如果信用值小于等于零，临时把当前并发任务单元调度切换为垃圾回收。利用这种方式可以抑制某个并发任务单元在垃圾回收阶段一直内存分配导致垃圾回收无法结束。

这样也会造成最后实质性的
STW，最后所有的并发任务单元都在执行垃圾回收，用户代码被暂停。为了解决这个问题，使用公共账户信用值策略解决，比如垃圾回收清理任务比较重，CPU2 和
CPU3
专门做垃圾回收，黑白对象标记完的对象数量累计到公共账户信用值。这个公共账户信用值用来给在标记阶段内存分配函数使用，如果小于等于零则调度切换为垃圾回收，切换后不停的增加信用值和检查公共账户信用值，尽早提前结束切换执行用户代码，保证用户代码和垃圾回收的并行。通过一种信用授权的机制来干涉，这也是我们在架构设计当中非常常用的做法。

很难说真正实现并发回收并发扫描，它在某些时候依然会把并发变成串行，依然会执行很长时间段 STW
操作，这种动态调度很多时候不可控，垃圾回收很多时候根本控制不了。

### 小结

垃圾回收器只是一种辅助装置，它不是核心装置只是辅助回收，它永远不可能让程序变的更好，任何时候写每行代码不能给垃圾回收器增加负担，垃圾回收器只是在完成一些简单的辅助工作，它没有办法让程序变的更智能效率更高，它只是完成一些辅助操作。

很多语言对垃圾回收器做了很多控制开关，有的语言适合并发扫描有的语言不适合，甚至大数据进行密集计算关闭
GC，直到内存用完导致系统崩溃为止，在崩溃之前保存状态重新执行读取状态，目的是把垃圾回收消耗的资源用来做密集计算。

在超大内存中扫描上亿个对象是一种消耗，我们有责任尽量减少对象的数量：

  * 一尽可能分配到堆上
  * 二把多个对象合并重复使用一块内存，比如数组。

数组对于垃圾回收只是一个对象，一块内存只扫描一次。整个线程栈是一个对象不需要扫描，因为线程栈内存是重复使用的。在线程栈用一个指针引用堆上的对象，只要检查线程栈引用哪些对象。

所以我们尽量不要依赖垃圾回收，第一保证用户逻辑是对的，第二保证算法写法性能最好的，第三保证相关成本是最低的，包括内存分配成本垃圾回收成本。

为了方便与作者交流与学习，GitChat 编辑团队组织了一个专栏读者交流群，添加小助手，回复关键字「361」给小助手伽利略获取入群资格。
![R2Y8ju](https://images.gitbook.cn/R2Y8ju.jpg)

