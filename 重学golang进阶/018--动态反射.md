---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 动态行为

动态语言没有反射的概念，因为动态语言按照名称或者符号表寻址，它的一切都是动态的。那么为什么出现反射这种技术呢？是因为静态语言在动态行为上有很大不足。

泛型不属于动态行为。泛型本身是一种基于模板的机制，相当于带有占位符的代码模板交给编译器 JIT 翻译，用具体类型替换占位符生成多套不同的代码。

动态通常是运行期的行为，一般用于调整算法、数据结构、解析未知的数据。注意解析 XML 或者 JSON 行为不属于动态，因为 XML 或者 JSON
是自我描述的文本，数据本身自带数据格式。

反射属于动态行为。大多数 ORM 都是基于反射实现，因为 ORM 不确定有哪些对象或者对象属性名和数据库字段名不一致，所以必须建立一种映射关系。

### 反射

对象由类型对象和对象实例组成。类型对象通常称之为 Class，存储相应的类型信息和方法调用；对象实例有标准的头信息和实例字段，头信息指针指向类型对象。

动态访问不能通过字段名称访问字段，而是通过类型指针加上偏移量访问字段。汇编中访问地址是基于开始位置加上偏移量，偏移量确定字段位置，类型确定字段长度。

我们通过动态查找利用接口方式或者通用类传递的对象，所属的类型指针来获取对应类型的信息。类型字段包括属于哪种类型的名字 Name，有哪些字段
Field，字段包括字段的名字和类型和内存布局上的偏移量。

接下来可以取得有哪些方法。我们知道所有的方法在 .text
段里都有地址，通过地址可以获得方法的指针、参数和返回值。从汇编角度看，函数调用是用这些信息依次入栈调用地址。类似的，反射可以理解在运行期生成的一段动态汇编代码，类型描述信息可以确定汇编代码执行的数据，其中包括元数据、起始地址、方法、字段名字、字段类型、字段偏移量，元数据用来描述类型的相关信息。利用这些数据生成动态调用代码也很容易，把这些元数据填进函数中，接下来就可以间接访问。

编译器通过源代码做静态绑定。如果动态绑定需要运行库支持，不同语言有不同做法，有 JIT
方式、有基于反射的方式动态获取元数据。反射是在运行期查找类型的元数据进行动态调用，把静态的操作变成运行期的动态操作。

### 实现方式：Go

反射怎么实现，不同的语言有不同的实现方式，多数语言每个对象头部有类型指针。Go 语言和 C 语言的对象实例没有头部指针，它的内存布局是第一个字段到第 N
个字段依次排列。

从哪里获得类型的格式？从哪里知道属于哪种类型？第一个解决的问题是对于没有类型表的类型对象怎么获取？第二个解决的问题是获取元数据后怎么调用或者获取值设置值？说白了需要解决这两个问题。

Go 语言对一个对象进行反射，首先调用 reflect.TypeOf 函数，这个函数的参数是空接口类型，意味着可以把任何对象传进去，返回的 Type
对象就是元数据。

那么这个函数是通过什么途径获取元数据信息的呢？接口是通过保存元数据进行间接调用，接口是由两个字段构成的，分别是接口表 iTab 和对象的复制品
data。iTab 中有三种元数据，分别是接口的详细元数据、对象的类型元数据、方法表。原始对象没有类型信息，把它转换成接口，通过接口变相的持有类型指针。

Go 语言这样实现有几个原因，第一对 C 语言的兼容，因为 C
语言没有反射；第二如果对象不使用反射和接口调用，不需要这些类型信息。接口调用和反射都是运行期行为，在运行期接口调用通过元数据判断是否实现了这个接口，通过方法集查找调用的函数。

在知道 Go 语言元数据的类型信息后，对源码感兴趣的打开 type.go 文件可以看到传进来的对象是通过指针转换转换为空接口类型
emptyInterface，这个空接口类型就是标准的接口结构，rtype 类型就是元数据。

有了这些动态信息后，这段内存格式解码相当于变成类似 JSON 这种自我描述的格式。数据加上元数据，元数据用来描述这段数据的。接下来的操作就非常容易。

所以反射本身并不复杂，通过指针或者其它方式获取类型信息对内存里一段数据进行解码。如何找到数据类型的元数据不同语言有不同做法，Java、C#、Python
语言对象头部有类型指针，Go
语言通过接口查找类型指针。通过类型指针找到类型对象，类型对象有完整的元数据，知道这段数据分成几块，每一块有多长，是什么类型，包含了哪些调用等信息，说白了就是把无格式或者未知类型的数据转换成有格式化的数据。

### 反射操作类别：类型元数据、实例状态

反射操作严格来说分成两种，第一种利用元数据查找一段数据的格式，在 ORM 中最常见的用来创建对应的表。第二种利用元数据对对象字段读取、修改和方法调用。

修改一段数据必须通过类型信息描述来获得数据在什么位置，长度有多少，数据类型是什么，内存里的数据都是字节数组，通过类型知道存储的是 bool 值、32
位整数还是 64 位整数？数据通过什么类型写入。同样的，调用方法需要从类型信息获取方法的地址、参数、顺序、返回值，进行入栈调用，完成动态调用。

### 基于反射动态调用

我们的两种行为，第一种是获取元数据信息；第二种是对实例的内存数据操作。Go 语言提供 reflect.TypeOf
返回元数据，reflect.ValueOf
对对象实例进行操作，它可以操作对象中的数据，读取或者修改某些数据。标准库提供的包装好行为的方法，我们传递已经反射格式化的数据，这些方法通过查找表信息进行相应的操作。

类似操作数据库行为，使用一些数据，通过 SQL，其实 SQL
就是有元数据在支撑，把数据写到相应数据库某个表。同理，内存中有段未知的数据，通过反射查到类型信息返回元数据，用标准库提供的操作方式来操作数据格式，最终完成具体的操作。

### 基于符号表动态调用

通过符号表也可以做动态调用，符号表表示某个符号名对应的地址。这个地址是在运行期一个指针，用指针转换把指针转换成某种函数类型可以正常调用。符号表就是相当于格式化的数据表，拿到地址后，地址转换成指针操作。但是符号表在程序发布时可以删除，删除后获取不到符号表。大部分语言都有类似的标准库用来获取符号表。Go
语言标准库 elf 包提供获取相应的符号表和段信息函数，段信息可以用来查找某个符号。

### 反射性能

反射所有的操作都需要查找元数据，这些就是反射有性能问题原因。静态时操作内存直接做一次内存寻址，动态时首先拿到符号名，在类型信息里找到类型对象，通过类型对象多次寻址找到目标数据，数据读出来是什么类型、有多长、偏移量是多少，计算出操作内存的指令翻译函数调用。显然这比静态汇编级别指令慢很多。

怎么优化反射的性能呢？第一种方式缓存每次查找的元数据行为，第二种方式把反射操作变相还原成汇编操作。

比如操作字段 X，通过类型信息找到需要操作的这个字段，接下来通过 Value 对它操作。查找过程可以缓存起来不需要每次都去查找类型信息，第一次找到 X
的字段和它的偏移量，X
的地址等于当前实例地址加上它的偏移量，使用指针操作赋值，这些语句就被编译器编译成汇编指令级别。我们实际上把反射调用还原成一个公式表达式避免反射带来的一些性能损失。

例子：

    
    
    func value(d interface{}) int64 {
        v := reflect.ValueOf(d).Elem()
        f := v.FieldByName("X")
    
        x := f.Int()
        x++
        f.SetInt(x)
    
        return x
    }
    
    var offset uintptr = 0xFFFF
    
    func unsafeValue(d interface{}) int64 {
        if offset == 0xFFFF {
            t := reflect.TypeOf(d).Elem()
            x, _ := t.FieldByName("X")
            offset = x.Offset
        }
    
        p := (*[2]uintptr)(unsafe.Pointer(&d)) // {itab, data}  = [2]uintptr
        px := (*int64)(unsafe.Pointer(p[1] + offset))
        *px++
    
        return *px
    }
    
    func main() {
        d := struct {
            X int
        }{100}
    
        println(value(&d))
        println(unsafeValue(&d))
    }
    

这是很简单的一个例子，有一个对象，这个对象有个字段 X。使用两种方式对字段操作。

第一种是反射方式操作，首先找到这个字段的名字，然后用反射的方式取出这个值，修改 X 值再写回去，这段代码相当于完成 `d.x++` 操作。

第二种是优化方式操作，使用一个变量用作缓存 X 的偏移量，设置初始值是不在范围内的值。第一次执行反射操作找到 X
的偏移量并保存到全局变量，下次这段代码不会执行。接着取到对象的地址，参数 d
是接口类型，接口类型有两个字段，所以把接口转换成两个指针类型的数组，数组的第一位保存的就是 d 的地址。对象地址加上 X 的偏移量得到 X
的地址。然后进行简单的指针操作。

    
    
    var d = struct {
        X int
    }{100}
    
    func BenchmarkValue(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _ = value(&d)
        }
    }
    
    func BenchmarkUnsafeValue(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _ = unsafeValue(&d)
        }
    }
    

性能测试，第 1 种方式测试反射模式，第 2 种方式测试优化模式，看看这每次操作性能差异到底有多大？

    
    
    $ go test -v -bench . -benchmem
    
    
    
    BenchmarkValue           20000000           105 ns/op           8 B/op          1 allocs/op
    BenchmarkUnsafeValue     500000000            3.19 ns/op        0 B/op          0 allocs/op
    

我们注意到优化过后和使用反射之前性能差异非常的大，还有最关键的是避免了一次堆上内存分配。因为 reflect.ValueOf(d)
需要额外的在堆上创建反射对象。所以使用优化方式规避反射的弊端，同样可以让性能变得很快。

> **感谢各位的光临哟！！**
> **获取更多资源:掘金小册,gitchat专栏,极客时间等资源；**
> **请到闲鱼店：583128058yanghon**
> **啊呜呜~~~**