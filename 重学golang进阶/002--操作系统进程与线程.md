---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 进程、线程的区别

在编程中最常见的三个概念是进程、线程、协程。

程序包含一系列资源，比如代码、图片、音视频、安装文件，程序是为了运行一段代码所需资源的总和。

进程严格上说也是资源的集合，相对于程序静态资源来说，进程大多是动态资源，比如运行期的虚拟内存空间，正在执行 CPU
缓存的数据，这些资源总和称之为进程，进程是一种资源单位，操作系统为资源单位做管理。

线程是和 CPU 交互的，进程由线程组成，线程在进程中主要负责执行指令，指令执行过程是首先从进程内存映射 .text
段映射里读出指令，然后在进程的堆栈中操作一些数据。线程处理数据的资源边界是在进程内的。

所以总结起来就是进程是一种资源单位，操作系统按照进程来分配资源管理资源。线程是进程内的，专门用来执行。

对于操作系统来说，操作系统的资源管理是以进程为单位的，操作系统分配资源是以进程为单位，每个进程有唯一的 Id，操作系统处理
`MMU`映射、文件表。进程里的线程之间共享资源是进程内部的事情。当程序执行的时候，必须有线程的概念，所以每个进程最少有一个线程，否则 CPU 没法执行。

### 系统线程和用户线程的区别

线程有两种状态，一种称之为系统线程或者内核线程、内核态，一种称之为用户线程。

![MXscWY](https://images.gitbook.cn/MXscWY.png)

系统线程是什么呢？以 Linux 为例，早期的 Linux 没有线程一说，所有的执行单位称之为任务，每个任务有一套独立的资源，类似一个进程有一个线程
(任务)，多个任务共享一系列资源，类似一个进程有多个线程 (任务)。

换句话说，任务是操作系统的执行单位。这样很容易理解，先用进程申请一系列资源，接下来创建多个任务，每个任务类似线程，区别在于任务是否共享资源。

但是严格来说任务和线程有区别，线程我们严格意义上来说指的是任务加上任务执行所需的资源，称之为线程，如果线程只是执行单位没有任何资源，称之为任务，它是可复用的，线程本身有状态的，因为线程执行时有线程栈，所以任务加上任务执行所需的线程栈等资源称之为线程。

假设分配资源单位是以进程为边界，比如有个进程有两个系统线程，对于操作系统来说就是映射两个执行单位，这两个执行单位都共享同一资源视作一个进程里的两个线程。

操作系统关心的是两个执行单位，操作系统给这两个执行单位分配时间片，执行单位之间是否共享资源和操作系统无关，因为操作系统看到的就是两个独立的执行单位，给每个执行单位分配时间片。

而用户线程在用户空间实现的，操作系统只给系统线程分配时间片，操作系统看不到用户空间的用户线程。

如果我们不使用系统线程分配，所有用户线程只能被一个核使用，CPU 时间片绝对不公平，比如 A 进程有两个系统线程，B
进程有两个用户线程只有一个系统线程。归根结底是用户线程操作系统根本看不到，因为它是抽象的概念不是操作系统提供的，操作系统根本不理解什么是用户线程。

所以`系统线程`指的是操作系统提供的的任务单元。`用户线程`指的是在用户空间实现的一些并发任务，跟操作系统没关系。操作系统分配执行单位是按照 CPU
时间片进行分配，用户线程就和系统线程的区别就是这个。

当选择一门语言或者一种并发库时必须知道它究竟是由系统线程实现的还是用户线程实现的，系统线程是可以直接被分配到多个核上执行，用户线程只能有一个分配到单核上执行，在性能上有很大差别。

### 系统线程的缺点

程序执行时存在两种状态，用户态和系统（内核）态。用户态执行的是用户代码，比如登录、用户注册。但是用户代码需要操作系统执行，操作系统执行时需进入系统态。

举个例子，例如文件读操作，实际上是调用 `open`，操作系统最终把这个 API 翻译成具体的系统调用
`syscall`在系统态执行，所以文件读操作实际分为用户态代码和系统态代码。当从用户态代码调用进入系统态代码调用时会涉及到上下文切换。

很显然系统线程的创建、调度的成本非常高，当我们频繁的去创建系统线程、销掉系统线程的代价有点高。

### 抽象系统线程池模型

既然频繁使用系统线程的成本比较高，在用户态和系统态基础上会实现这样的模型。

  1. 在用户态抽象出多个执行单位。
  2. 把用户态的线程映射到少量的系统线程上，建立类似 `Pool`的模型复用系统线程。

这样内核态的系统线程负责执行，用户态的线程负责存储状态，比如存储线程栈状态。所有用户态线程执行保存当时执行线程状态，包含寄存器相关的信息、局部变量。

使用池模型不再需要频繁的创建系统线程，用户态可以创建很多用来存储状态的执行单位。执行时把它绑定到一个系统线程上去执行，执行完把系统线程释放，系统线程把绑定状态删除放到池中，不需要杀掉系统线程，接下来另外一个执行单位重新的绑定到这个系统线程上去执行。

如下图所示：

![hmxRw6](https://images.gitbook.cn/hmxRw6.png)

首先创建一定数量的系统线程专门用来执行的。其次在用户态空间创建一些对象专门用来保存执行时所需要的状态，包括线程栈。它不负责执行，它只是很普通的数据抽象容器。它执行时把它绑定到某个系统线程上，这个系统线程就具备了普通线程状态然后去执行，执行完把这个线程的状态全部剥离，这个线程就恢复成原始状态，接下来可以执行其他的任务。

### 编程语言对线程的抽象

所以现代语言往往会在系统线程之上做一次抽象。在用户态空间实现用来保存状态的用户线程，用户线程不负责执行只负责保存用户状态，所有的执行最终交给底层的系统线程执行。

在底层实现类似并行，我们在用户态只需要创建大量的并发任务，通过调度器实现这两个层面上的绑定，从而实现用户态的执行和系统态的执行分离，避免反复系统调用所消耗的资源。

所以我们判断的时候不要说推其一而推导出全部，设计的好或不好都是相对的没有绝对的，因为在实际的运用当中我们往往会把很多东西去结合起来尽可能发挥它的优势来避免它的缺陷，我们必须要做出大量的积累然后去设计出一种相对来说比较和谐的执行方式，尽可能发挥所有机制的优点来隐藏它的缺点。

通过这小节的学习知道一些概念，也知道了系统线程和用户线程在 CPU 时间片上的区别。编程语言会在进程、线程的基础上设计一层抽象。

