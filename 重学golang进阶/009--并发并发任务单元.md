---
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
export_on_save:
  html: true
  puppeteer: true
---
### 并发任务单元

    
    
    go func(s string) {println(s)
       }("hello")
    

  * go 语句创建并发任务单元(goroutine)，并打包函数执行所需参数。
  * 并发任务稍后由调度器调度执行。
  * 进程内所有用户代码均以 goroutine 方式执行。
  * 创建 goroutine 后，不阻塞。
  * 任务单元自带栈内存(2KB-1GB)。

Go 语言写并发非常容易，因为所有的用户代码都是放在并发里执行的，包括 main 入口函数所有的函数都处在并发单元上执行。并发任务单元称之为
goroutine。

### 执行流程

当我们执行 Go 指令的时候，实际上它会创建一个并发任务，函数名字或者指针加上参数打包创建一个新的 goroutine，放到本地队列，然后 main
goroutine 不会等待 goroutine 什么时候执行，main goroutine 会继续执行后面的逻辑。

什么时候执行 goroutine 是调度器调度的与当前的 main
函数无关。因为当前有很多并发线，本地队列还会与全局队列进行交互。正常情况下，并发线从自己的本地队列查找准备运行的
goroutine，如果本地队列没有，则到全局队列查找。每个本地队列大小有 256 个限制，如果多就会把一半转移给全局队列给其他的并发线使用。

如果其它并发线本地队列没有就会从全局队列取
goroutine，如果全局队列没有则到其他并发线的本地队列取，因为调度器有责任让所有等待运行队列里并发单元尽可能快地执行。

所以对于 main 函数来说，创建了并发单元，这个任务未必由 main
执行，因为放到本地队列会面临两种状况，一种状况是本地队列满了被转移到全局队列里，全局队列接下来被谁执行不知道。第二种状况是放到本地队列也可能被别的并发线取走。调度器怎么实现调度算法是不对外公开的，没有在语言规范规定按照什么样的顺序来执行。

**1\. 创建并发调用，而注册函数**

Go 并发模型实现创建并发任务单元非常简单，在函数前面加上 go 关键字就可以了。go 关键字不是立即执行，它与 defer
延迟执行类似，它严格上说是一个函数调用，实际注册函数和函数需要的参数打包，构建成一个并发任务。

    
    
    func test() {
        // 模拟时间长的任务
        time.Sleep(time.Second)
        println("goroutine")
    }
    
    func main() {go test() // 启动一个并发任务 [test ()] --> sched
        println("hello")
    }
    

运行上面例子我们发现启动的一个并发任务 `test()` 并没有执行。

启动 `go test()`
在调度器或者运行时注册行为，注册后继续执行。至于谁执行什么时候执行正常流程不知道。因为当前执行序和并发任务执行序不是同一个执行序。它只是向调度器发送类似异步的信号，这个信号包含了一些数据载体，包括函数名字和函数所需要的参数，除此之外跟当前执行序没有关系。

线程分两种状态，第一种称之为前台线程，主线程会等待前台线程执行完再结束，最后会隐式实现等待所有前台线程结束。第二种背景线程，后台执行对前台线程没有干扰，除非显式去等待。对于
Go 来说，当做背景线程来执行。

**2\. 参数复制**

    
    
    func test(x int) {time.Sleep(time.Second)
        println(x)
    }
    
    func main() {
        x := 100
        go test(x)
    
        x = 200
        println(x)
    
        time.Sleep(time.Second * 3)
    }
    

当注册时，会立即复制参数，如果是值复制值，如果是指针复制指针。

`go test(x)` 注册异步信号时就复制参数，并不是在执行时才去读取这个值。

如果希望对参数有影响最简单做法使用指针。

    
    
    func test(x *int) {time.Sleep(time.Second)
        println(&x)
    }
    
    func main() {
        x := 100
        go test(&x)
    
        x = 200
        println("hello")
    
        time.Sleep(time.Second * 3)
    }
    

所以在写并发任务时要注意传递给并发任务的参数是什么。通常意义上来说，尽量避免和另外一个并发任务同时共享数据。原因有两点：

  * 两个并发任务会产生数据竞争效应导致数据紊乱。在没有办法控制先后次序的情况下，修改同一数据可能导致修改出现紊乱，因为读和写操作不是原子操作。
  * 两个并发任务在两个物理核上执行导致数据紊乱。比如并发任务 A 把读取 100，加 200 写入。并发任务 B 执行同样的任务，把数据改成 200，那么并发任务 A 加 200 可能返回 400 和期望的数据不符。

如果数据和当前线程有依赖有两种方案：

  * 第一种方案是锁机制。拿不到锁会一直等待直到拿到锁，锁机制保证类似于原子操作，或者称之为事务操作。加锁后即使在两个物理核上执行并发任务，原来是并行模式也变成串行模式。

  * 第二种方案是管道，移交控制权。

**3\. goroutine 执行时无法控制**

进程可以设置亲和值调整优先级，优先级高的话在内核调度上是优先的。线程可以设置优先级，线程只是向操作系统提一个建议，至于操作系统怎么排序和操作系统本身的算法有关系。

Go 启动一个并发任务，只是向调度器进行注册，接下来所有的事情都无法控制，没法控制什么时候执行什么时候结束和优先级。

### 等待

    
    
    func main() {c := make(chan struct{})
        go func(s string) {defer close(c)
            println(s)
        }("hello")
        <-c
    }
    

  * 进程默认不会等待未执行 goroutine 结束。
  * 同样不能保证 goroutine 内的 defer 得以执行。
  * 可使用 chan 或 sync.WaitGroup 等方式显式等待。

上面例子创建一个并发任务来打印字符串，假设 main 函数在线程 1 执行，并发任务可能在线程 2 执行，多线程编程中使用 `join()`
等待结束，`T1.join()` 等待 T1 结束。

Go 无法直接创建线程，线程是调度器创建的，那我们怎么等待并发任务结束呢？

  * 第一种：等待方式使用管道，管道类似消息队列，定义一个管道，从管道中等待信号，如果没收到信号一直等待不退出。并发任务执行完成发送管道关闭信号，管道接收到信号后退出。

  * 第二种：等待方式使用同步 `sync.WaitGroup` 等待。它有很简单的理念就是计数器，提供一个计数器每次创建任务把计数器累加，任务结束时候把计数器减去一，等待计数器为零时候退出。

第二种等待方式：

    
    
    func test(id int, wg *sync.WaitGroup) {defer wg.Done() // 计数器减去 1 defer 保证下面语句出错也能执行
    
        time.Sleep(time.Second)
        println(id, "done.")
    }
    
    func main() {
        var wg sync.WaitGroup
    
        for i := 0; i < 10; i++ {wg.Add(1)       // 计数器增加
            go test(i, &wg) // register
        }
        wg.Wait()// 计数器为 0，阻塞解除}
    

上面例子定义 test 函数，接收一个参数，用 sleep 模拟长时间。

这里注意到每次执行顺序都不一样，因为我们没法控制先后执行。

这和传统的多线程编程不太一样，多线程编程可以获取另外一个线程的引用，等待那个线程结束。goroutine
必须借助额外的手段等待，要么用通道要么用同步方式等待结束。

### 并发限制

  * 调度器默认允许多个 (logic cpu) 任务并发执行。
  * 可使用 GOMAXPROCS 调整。

我们可能创建很多并发任务，并发任务被分散到多个本地队列 P
中，本地队列都会连接全局队列。并发任务首先放到与当前执行序相绑定的本地队列中，如果本地队列满了就放到全局队列中，调度器会通知 MP
执行本地队列，再执行全局队列。我们没法检测当前本地队列有多少任务，当前本地队列有多长。

P
的数量决定当前有多少个并发任务可以同时执行。从物理上限制物理核的数量，从逻辑上来说受限于对线程的控制。在逻辑上两个线程在一个核上进行交叉执行属于同时执行。虽然物理上不是并发执行，但是这两个线程的确并发执行。

如果同时并发任务设置的好，处理速度就会很快否则会很慢。不是越多越好得有适当的范围。Go
里面可以通过函数的方式或者通过环境变量方式控制并发的数量。它默认情况下按照逻辑 CPU 数量设置并发数。

下面例子看并发控制对程序执行有什么影响。

    
    
    func test(wg *sync.WaitGroup) {defer wg.Done()
        x := 0
        for i := 0; i < math.MaxUint32; i++ {x++}
    }
    
    func main() {runtime.GOMAXPROCS(4) // 设置 1 核和 4 核
        var wg sync.WaitGroup
    
        for i := 0; i < 3; i++ {wg.Add(1)
            go test(&wg)
        }
        wg.Wait()}
    

修改代码设置 1 核和 4 核，观察运行时间：

    
    
    $ time go run main.go
    

### 本地存储

    
    
    var gs [5]struct { // 用于实现类似 TLS 功能。
        id     int // 编号
        result int // 返回值
    }
    
    func main() {
        var wg sync.WaitGroup
        for i := 0; i < len(gs); i++ {wg.Add(1)
            go func(id int) { // 使用参数避免闭包延迟求值
                defer wg.Done()gs[id].id = id
                gs[id].result = (id + 1) * 100
            }(i)
        }
        wg.Wait()fmt.Printf("%+v\n", gs)
    }
    

  * 与线程不同，goroutine 没有 TLS（Thread Local Storage）功能。
  * 可通过参数实现（注意处理 false sharing）。

在多线程编程中本地存储技术非常常用。每个线程都有自己的执行栈，执行栈是当前线程私有的，线程 1 和线程 2 的执行栈肯定不一样的。对于全局变量来说，线程 1
和线程 2 是共享的，如果线程 1 和线程 2 都需要访问全局变量，线程 1 和线程 2 存在数据竞争效应。

在多线程编程中使用全局变量的目的是避免参数在各个函数间传递，因为全局变量在每级堆栈帧都可以访问，而参数在调用堆栈帧上一级一级传递。本地存储技术可以把全局变量或者静态变量设置为线程私有，把一个变量声明为本地存储技术模式，实际上每个线程都会创建一个。全局变量看上去和每个线程绑定的，类似每个线程都拥有独立的全局变量。使用
TLS 模式的优点是每个线程都互相之间不影响。

在很多语言里可以定义一个变量声明 TLS 模式，即线程 1 拥有一个独立的变量，线程 2 也拥有自己的独立的变量，线程 1 和线程 2
使用专门的区域分开存储变量。

基于 TLS 可以设计出各种模式，比如缓存中的全局缓冲器。每个线程使用的缓存肯定不是同一个，无论哪个堆栈帧都可以从自己的缓存器中获取对象。

Go 不支持本地存储，理由有两个：

  * 第一：因为本地存储是利用线程机制实现，需要和线程绑定。Go 创建并发任务，可能会被多个线程调度执行，如果全局变量存在线程 1 上，但是线程 2 上没有就取不到了。

  * 第二：因为 goroutine 实现机制是，线程不存储并发任务状态，是用来执行的。并发任务的状态保存在并发任务中，而 TLS 所有的状态和线程绑定的，这是两种不同的执行模式。

如果实现类似 TLS 功能，我们可以创建个全局变量数组用于保存 TLS，怎么做呢？

上面例子创建五个 goroutine，每个 goroutine 需要单独存储数据。使用类似数组结构体的方式，每个 goroutine
都有自己独立的索引保存数据。这个数组是被共享的，每个 goroutine 只操作其中一个元素，当然这也会涉及伪共享的问题。

Go 提供简单的测试方式，先编译 `go build -race`
再执行提供数据竞争检测，就是两个并发逻辑访问同一个资源的时候，存在数据竞争的话可能会导致数据结构破坏。

我们建议 goroutine 通过参数传递，避免使用全局变量。这是两种不同的模型。因为 goroutine 设计线程是无状态的，而传统 TLS
模型线程是有状态的。线程除了有执行栈以外还有 TLS 区域保存临时状态，这个状态除非清除掉，否则一直随着线程存在。

### 切换调度

    
    
    func main() {runtime.GOMAXPROCS(1)
        var wg sync.WaitGroup
        for i := 0; i < 2; i++ {wg.Add(1)
            go func(id int) {defer wg.Done()
                fmt.Println(id, "exec...")
                for x := 0; x < 10; x++ {// runtime.Gosched()
                    println(id, ":", x)
                }
            }(i)
        }
        wg.Wait()}
    

> 保存当前任务状态，将其放回任务队列，转而调度执行其他任务。

执行一个任务，由于某种原因需要很长时间，它可能需要等待异步调用，则会考虑把任务临时放回队列。

很多语言提供类似这样的能力。其实质是正常情况下任务按顺序执行，执行到某行时因为某种原因满足不了，需要长时间的阻塞或者等待。这时候从 CPU
时间片的角度说，执行到某行因为不满足通过等待消耗剩余时间片非常不合理。

执行 `runtime.Gosched()` 调度操作，保存当前 goroutine
状态不执行后面操作，调度器把当前任务放回到任务队列等待下次恢复执行，把剩下的 CPU 时间片节省下来。它的具体含义是主动交出控制权，类似 yeild。

正常情况下不需要切换调度。特殊情况下比如 goroutine 不支持的机制导致调度器不能正常调用，执行很长时间的等待，比如调用 C
或者在消息队列等待消息。Go 语言里多数情况下没必要这么做，因为标准库遇到阻塞会自动放回运行队列。

上面例子在函数内部执行循环的打印输出。有两个 goroutine 等待执行，加上 main 有三个，控制只有一条并发线，必然是执行完 goroutine
才能执行另外一个 goroutine，串行执行整个循环，把控制权让出来变成交互执行。

### 任务终止

    
    
    func main() {c := make(chan struct{})
        go func() {defer close(c)
            func() {// runtime.Goexit()
                return
            }()println("done")
        }()
        <-c
        println("exit")
    }
    

  * Goexit 终止整个任务，return 仅终止当前函数。
  * Goexit 确保 defer 得以执行。
  * 在 main goroutine 调用 Goexit 会等待其他任务结束，随后让进程崩溃。

Go 提供 `runtime.Goexit()` 用来中止整个 goroutine，它实际上不关心调用链，`G` 对象在调用时里面可能有很多调用链，某个
`M` 执行。Go 在任何地方一旦调用退出 `Goexit` 方法的时候，实际上是告诉 `M` 停止执行同时放弃任务，也就是完全丢弃掉不要放入队列中，`M`
去执行其他的 `G` 任务。这样一来整个调用堆栈帧内存取消掉，普通的 `return` 实际上是需要维持上一级的堆栈帧的。

上面的例子是执行一个任务，用通道等待，使用 `return` 表示结束当前函数，在函数内部执行 `return`
只是结束当前堆栈帧逻辑，并没有办法控制上一层栈帧的逻辑。使用 `runtime.Goexit()` 是结束当前 goroutine 回到调度器。

我们看下面的逻辑链，调用相应的逻辑链，a 执行到 b，b 执行到 c，我们希望任何一个环节一旦出现问题中止整个链，不是说回到上一层。

    
    
    func a() {println("a start.")
        b()println("a end.")
    }
    
    func b() {println("b start.")
        c()println("b end.")
    }
    func c() {println("c start.")
        runtime.Goexit()
        //return
        println("c end.")
    }
    
    func main() {a()
    }
    

### 环境变量

    
    
    $ GODEBUG=schedtrace=1000,scheddetail=1
    

运行时提供相关环境变量，用于查看调度器信息。

  * schedtrace：输出调度器相关统计状态。
  * scheddetail：输出调度器状态细节。

